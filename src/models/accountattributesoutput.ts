/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  TransferDestinationCapability,
  TransferDestinationCapability$inboundSchema,
} from "./transferdestinationcapability.js";

/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export const AccountAttributesDepositoryVerificationStatus = {
  VerificationPending: "VERIFICATION_PENDING",
  VerificationFailed: "VERIFICATION_FAILED",
  Verified: "VERIFIED",
} as const;
/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export type AccountAttributesDepositoryVerificationStatus = ClosedEnum<
  typeof AccountAttributesDepositoryVerificationStatus
>;

export type AccountAttributesDepositoryAccountBalances = {
  /**
   * The amount of funds available to be withdrawn from the account.
   *
   * @remarks
   *
   * For earnings_balance-type accounts, the available balance typically
   * equals the current balance less any pending outflows, plus any pending inflows,
   *
   * This value is in units of the lowest denomination in the associated
   * currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
   * $72.50.
   */
  available: number | null;
  /**
   * The total amount of funds settled in the account.
   *
   * @remarks
   *
   * This value is in units of the lowest denomination in the associated
   * currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
   * $72.50.
   *
   * **Special note for earnings_balance-type accounts:**
   * During a typical pay period, if a user transfers no money from an earnings_balance-type account to a personal account,
   * the `current` balance will generally be 0, because transfers from earnings to this account will be
   * PENDING until the paycheck related to those earnings is processed.
   * Pending inflows are included in the `available` balance, not the `current` balance.
   *
   * If a user transfers money from an earnings_balance-type account to a personal account,
   * the `current` balance will be negative as those transfers settle. When a paycheck is processed,
   * DailyPay will automatically attempt to zero out the balance,
   * transferring any remaining funds to the `default_paycheck_destination` set for the associated Job.
   *
   * If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,
   * which may impact a user's ability to transfer additional funds from their earnings balance.
   * In those cases, the available balance will be 0.
   */
  current: number | null;
  /**
   * A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
   */
  currency: string;
};

export type AccountAttributesDepositoryAccountCapabilities = {
  /**
   * List of the timing and associate fees available when crediting this account as a
   *
   * @remarks
   * transfer destination.
   *
   * Actual fees may differ at the time of transfer; please refer to
   * the transfer preview attribute for the most accurate fee information
   * for any given transfer.
   */
  transferDestination: Array<TransferDestinationCapability>;
};

/**
 * The subtype of the account.
 */
export const AccountAttributesDepositorySubtype = {
  Savings: "SAVINGS",
  Checking: "CHECKING",
} as const;
/**
 * The subtype of the account.
 */
export type AccountAttributesDepositorySubtype = ClosedEnum<
  typeof AccountAttributesDepositorySubtype
>;

/**
 * The banking details of the account and account holder.
 */
export type DepositoryAccountDetails = {
  /**
   * The first name of the account holder.
   */
  firstName: string;
  /**
   * The last name of the account holder.
   */
  lastName: string;
  /**
   * The routing number of the bank that holds this account. Responses from this API that return this number are masked to the last four digits.
   */
  routingNumber: string;
  /**
   * The account number. Responses from this API that return this number are masked to the last four digits.
   */
  accountNumber: string;
};

/**
 * An account with type `DEPOSITORY` and subtype `SAVINGS` or `CHECKING`.
 */
export type Depository = {
  /**
   * A code that indicates the status of an account that is a destination for funds.
   */
  verificationStatus: AccountAttributesDepositoryVerificationStatus;
  accountBalances: AccountAttributesDepositoryAccountBalances;
  accountCapabilities: AccountAttributesDepositoryAccountCapabilities;
  /**
   * Display name for this account.
   */
  name: string;
  /**
   * The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
   */
  accountType: "DEPOSITORY";
  /**
   * The subtype of the account.
   */
  subtype: AccountAttributesDepositorySubtype;
  /**
   * The banking details of the account and account holder.
   */
  depositoryAccountDetails: DepositoryAccountDetails;
};

/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export const AccountAttributesEarningsBalanceVerificationStatus = {
  VerificationPending: "VERIFICATION_PENDING",
  VerificationFailed: "VERIFICATION_FAILED",
  Verified: "VERIFIED",
} as const;
/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export type AccountAttributesEarningsBalanceVerificationStatus = ClosedEnum<
  typeof AccountAttributesEarningsBalanceVerificationStatus
>;

export type AccountAttributesEarningsBalanceAccountBalances = {
  /**
   * The amount of funds available to be withdrawn from the account.
   *
   * @remarks
   *
   * For earnings_balance-type accounts, the available balance typically
   * equals the current balance less any pending outflows, plus any pending inflows,
   *
   * This value is in units of the lowest denomination in the associated
   * currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
   * $72.50.
   */
  available: number | null;
  /**
   * The total amount of funds settled in the account.
   *
   * @remarks
   *
   * This value is in units of the lowest denomination in the associated
   * currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
   * $72.50.
   *
   * **Special note for earnings_balance-type accounts:**
   * During a typical pay period, if a user transfers no money from an earnings_balance-type account to a personal account,
   * the `current` balance will generally be 0, because transfers from earnings to this account will be
   * PENDING until the paycheck related to those earnings is processed.
   * Pending inflows are included in the `available` balance, not the `current` balance.
   *
   * If a user transfers money from an earnings_balance-type account to a personal account,
   * the `current` balance will be negative as those transfers settle. When a paycheck is processed,
   * DailyPay will automatically attempt to zero out the balance,
   * transferring any remaining funds to the `default_paycheck_destination` set for the associated Job.
   *
   * If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,
   * which may impact a user's ability to transfer additional funds from their earnings balance.
   * In those cases, the available balance will be 0.
   */
  current: number | null;
  /**
   * A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
   */
  currency: string;
};

export type AccountAttributesEarningsBalanceAccountCapabilities = {
  /**
   * List of the timing and associate fees available when crediting this account as a
   *
   * @remarks
   * transfer destination.
   *
   * Actual fees may differ at the time of transfer; please refer to
   * the transfer preview attribute for the most accurate fee information
   * for any given transfer.
   */
  transferDestination: Array<TransferDestinationCapability>;
};

/**
 * An empty object for earnings balance accounts.
 */
export type Details = {};

/**
 * An account with type `EARNINGS_BALANCE` and subtype `ODP`.
 */
export type EarningsBalanceReadOnly = {
  /**
   * A code that indicates the status of an account that is a destination for funds.
   */
  verificationStatus: AccountAttributesEarningsBalanceVerificationStatus;
  accountBalances: AccountAttributesEarningsBalanceAccountBalances;
  accountCapabilities: AccountAttributesEarningsBalanceAccountCapabilities;
  /**
   * Display name for this account.
   */
  name: string;
  /**
   * The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
   */
  accountType: "EARNINGS_BALANCE";
  /**
   * The subtype of the account.
   */
  subtype: "ODP";
  /**
   * An empty object for earnings balance accounts.
   */
  details: Details;
};

/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export const AccountAttributesCardVerificationStatus = {
  VerificationPending: "VERIFICATION_PENDING",
  VerificationFailed: "VERIFICATION_FAILED",
  Verified: "VERIFIED",
} as const;
/**
 * A code that indicates the status of an account that is a destination for funds.
 */
export type AccountAttributesCardVerificationStatus = ClosedEnum<
  typeof AccountAttributesCardVerificationStatus
>;

export type AccountAttributesCardAccountBalances = {
  /**
   * The amount of funds available to be withdrawn from the account.
   *
   * @remarks
   *
   * For earnings_balance-type accounts, the available balance typically
   * equals the current balance less any pending outflows, plus any pending inflows,
   *
   * This value is in units of the lowest denomination in the associated
   * currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
   * $72.50.
   */
  available: number | null;
  /**
   * The total amount of funds settled in the account.
   *
   * @remarks
   *
   * This value is in units of the lowest denomination in the associated
   * currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
   * $72.50.
   *
   * **Special note for earnings_balance-type accounts:**
   * During a typical pay period, if a user transfers no money from an earnings_balance-type account to a personal account,
   * the `current` balance will generally be 0, because transfers from earnings to this account will be
   * PENDING until the paycheck related to those earnings is processed.
   * Pending inflows are included in the `available` balance, not the `current` balance.
   *
   * If a user transfers money from an earnings_balance-type account to a personal account,
   * the `current` balance will be negative as those transfers settle. When a paycheck is processed,
   * DailyPay will automatically attempt to zero out the balance,
   * transferring any remaining funds to the `default_paycheck_destination` set for the associated Job.
   *
   * If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,
   * which may impact a user's ability to transfer additional funds from their earnings balance.
   * In those cases, the available balance will be 0.
   */
  current: number | null;
  /**
   * A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
   */
  currency: string;
};

export type AccountAttributesCardAccountCapabilities = {
  /**
   * List of the timing and associate fees available when crediting this account as a
   *
   * @remarks
   * transfer destination.
   *
   * Actual fees may differ at the time of transfer; please refer to
   * the transfer preview attribute for the most accurate fee information
   * for any given transfer.
   */
  transferDestination: Array<TransferDestinationCapability>;
};

/**
 * The subtype of the account. Additional subtypes may be added over time
 */
export const AccountAttributesCardSubtype = {
  Debit: "DEBIT",
  Dailypay: "DAILYPAY",
} as const;
/**
 * The subtype of the account. Additional subtypes may be added over time
 */
export type AccountAttributesCardSubtype = ClosedEnum<
  typeof AccountAttributesCardSubtype
>;

/**
 * The banking details of the account and account holder.
 */
export type CardAccountDetailsOutput = {
  /**
   * Last four digits of the card number.
   */
  lastFour: string;
  /**
   * The issuer of the card.
   */
  issuer: string;
  /**
   * The first name of the account holder.
   */
  firstName: string;
  /**
   * The last name of the account holder.
   */
  lastName: string;
  /**
   * The month of the expiration date for the card.
   */
  expirationMonth: string;
  /**
   * The year of the expiration date for the card.
   */
  expirationYear: string;
};

/**
 * An account with type `CARD` and subtype `DAILYPAY` or `DEBIT`.
 */
export type CardOutput = {
  /**
   * A code that indicates the status of an account that is a destination for funds.
   */
  verificationStatus: AccountAttributesCardVerificationStatus;
  accountBalances: AccountAttributesCardAccountBalances;
  accountCapabilities: AccountAttributesCardAccountCapabilities;
  /**
   * Display name for this account.
   */
  name: string;
  /**
   * The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
   */
  accountType: "CARD";
  /**
   * The subtype of the account. Additional subtypes may be added over time
   */
  subtype: AccountAttributesCardSubtype;
  /**
   * The banking details of the account and account holder.
   */
  cardAccountDetails: CardAccountDetailsOutput;
};

/**
 * The details of the account.
 */
export type AccountAttributesOutput =
  | CardOutput
  | EarningsBalanceReadOnly
  | Depository;

/**
 * An account with type `DEPOSITORY` and subtype `SAVINGS` or `CHECKING`.
 */
export type DepositoryInput = {
  /**
   * Display name for this account.
   */
  name: string;
  /**
   * The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
   */
  accountType: "DEPOSITORY";
  /**
   * The subtype of the account.
   */
  subtype: AccountAttributesDepositorySubtype;
  /**
   * The banking details of the account and account holder.
   */
  depositoryAccountDetails: DepositoryAccountDetails;
};

/**
 * An account with type `EARNINGS_BALANCE` and subtype `ODP`.
 */
export type EarningsBalanceReadOnlyInput = {};

/**
 * The banking details of the account and account holder.
 */
export type CardAccountDetailsInput = {
  /**
   * A tokenized string replacement for the card data.
   */
  token: string;
  /**
   * The issuer of the card.
   */
  issuer: string;
  /**
   * The first name of the account holder.
   */
  firstName: string;
  /**
   * The last name of the account holder.
   */
  lastName: string;
  /**
   * The month of the expiration date for the card.
   */
  expirationMonth: string;
  /**
   * The year of the expiration date for the card.
   */
  expirationYear: string;
  /**
   * The first line of the address for the card.
   */
  addressLineOne: string;
  /**
   * The second line of the address for the card.
   */
  addressLineTwo?: string | undefined;
  /**
   * The city of the address for the card.
   */
  addressCity: string;
  /**
   * The two-letter abbreviation of the state in the address for the card.
   */
  addressState: string;
  /**
   * The zip code of the address for the card.
   */
  addressZipCode: string;
  /**
   * The country code of the address for the card.
   */
  addressCountry: string;
};

/**
 * An account with type `CARD` and subtype `DAILYPAY` or `DEBIT`.
 */
export type CardInput = {
  /**
   * Display name for this account.
   */
  name: string;
  /**
   * The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
   */
  accountType: "CARD";
  /**
   * The subtype of the account. Additional subtypes may be added over time
   */
  subtype: AccountAttributesCardSubtype;
  /**
   * The banking details of the account and account holder.
   */
  cardAccountDetails: CardAccountDetailsInput;
};

/**
 * The details of the account.
 */
export type AccountAttributesInput =
  | CardInput
  | DepositoryInput
  | EarningsBalanceReadOnlyInput;

/** @internal */
export const AccountAttributesDepositoryVerificationStatus$inboundSchema:
  z.ZodNativeEnum<typeof AccountAttributesDepositoryVerificationStatus> = z
    .nativeEnum(AccountAttributesDepositoryVerificationStatus);

/** @internal */
export const AccountAttributesDepositoryAccountBalances$inboundSchema:
  z.ZodType<AccountAttributesDepositoryAccountBalances, z.ZodTypeDef, unknown> =
    z.object({
      available: z.nullable(z.number().int()),
      current: z.nullable(z.number().int()),
      currency: z.string(),
    });

export function accountAttributesDepositoryAccountBalancesFromJSON(
  jsonString: string,
): SafeParseResult<
  AccountAttributesDepositoryAccountBalances,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesDepositoryAccountBalances$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AccountAttributesDepositoryAccountBalances' from JSON`,
  );
}

/** @internal */
export const AccountAttributesDepositoryAccountCapabilities$inboundSchema:
  z.ZodType<
    AccountAttributesDepositoryAccountCapabilities,
    z.ZodTypeDef,
    unknown
  > = z.object({
    transfer_destination: z.array(TransferDestinationCapability$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "transfer_destination": "transferDestination",
    });
  });

export function accountAttributesDepositoryAccountCapabilitiesFromJSON(
  jsonString: string,
): SafeParseResult<
  AccountAttributesDepositoryAccountCapabilities,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesDepositoryAccountCapabilities$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AccountAttributesDepositoryAccountCapabilities' from JSON`,
  );
}

/** @internal */
export const AccountAttributesDepositorySubtype$inboundSchema: z.ZodNativeEnum<
  typeof AccountAttributesDepositorySubtype
> = z.nativeEnum(AccountAttributesDepositorySubtype);
/** @internal */
export const AccountAttributesDepositorySubtype$outboundSchema: z.ZodNativeEnum<
  typeof AccountAttributesDepositorySubtype
> = AccountAttributesDepositorySubtype$inboundSchema;

/** @internal */
export const DepositoryAccountDetails$inboundSchema: z.ZodType<
  DepositoryAccountDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  first_name: z.string(),
  last_name: z.string(),
  routing_number: z.string(),
  account_number: z.string(),
}).transform((v) => {
  return remap$(v, {
    "first_name": "firstName",
    "last_name": "lastName",
    "routing_number": "routingNumber",
    "account_number": "accountNumber",
  });
});
/** @internal */
export type DepositoryAccountDetails$Outbound = {
  first_name: string;
  last_name: string;
  routing_number: string;
  account_number: string;
};

/** @internal */
export const DepositoryAccountDetails$outboundSchema: z.ZodType<
  DepositoryAccountDetails$Outbound,
  z.ZodTypeDef,
  DepositoryAccountDetails
> = z.object({
  firstName: z.string(),
  lastName: z.string(),
  routingNumber: z.string(),
  accountNumber: z.string(),
}).transform((v) => {
  return remap$(v, {
    firstName: "first_name",
    lastName: "last_name",
    routingNumber: "routing_number",
    accountNumber: "account_number",
  });
});

export function depositoryAccountDetailsToJSON(
  depositoryAccountDetails: DepositoryAccountDetails,
): string {
  return JSON.stringify(
    DepositoryAccountDetails$outboundSchema.parse(depositoryAccountDetails),
  );
}
export function depositoryAccountDetailsFromJSON(
  jsonString: string,
): SafeParseResult<DepositoryAccountDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DepositoryAccountDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DepositoryAccountDetails' from JSON`,
  );
}

/** @internal */
export const Depository$inboundSchema: z.ZodType<
  Depository,
  z.ZodTypeDef,
  unknown
> = z.object({
  verification_status:
    AccountAttributesDepositoryVerificationStatus$inboundSchema,
  balances: z.lazy(() =>
    AccountAttributesDepositoryAccountBalances$inboundSchema
  ),
  capabilities: z.lazy(() =>
    AccountAttributesDepositoryAccountCapabilities$inboundSchema
  ),
  name: z.string(),
  account_type: z.literal("DEPOSITORY"),
  subtype: AccountAttributesDepositorySubtype$inboundSchema,
  details: z.lazy(() => DepositoryAccountDetails$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "verification_status": "verificationStatus",
    "balances": "accountBalances",
    "capabilities": "accountCapabilities",
    "account_type": "accountType",
    "details": "depositoryAccountDetails",
  });
});

export function depositoryFromJSON(
  jsonString: string,
): SafeParseResult<Depository, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Depository$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Depository' from JSON`,
  );
}

/** @internal */
export const AccountAttributesEarningsBalanceVerificationStatus$inboundSchema:
  z.ZodNativeEnum<typeof AccountAttributesEarningsBalanceVerificationStatus> = z
    .nativeEnum(AccountAttributesEarningsBalanceVerificationStatus);

/** @internal */
export const AccountAttributesEarningsBalanceAccountBalances$inboundSchema:
  z.ZodType<
    AccountAttributesEarningsBalanceAccountBalances,
    z.ZodTypeDef,
    unknown
  > = z.object({
    available: z.nullable(z.number().int()),
    current: z.nullable(z.number().int()),
    currency: z.string(),
  });

export function accountAttributesEarningsBalanceAccountBalancesFromJSON(
  jsonString: string,
): SafeParseResult<
  AccountAttributesEarningsBalanceAccountBalances,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesEarningsBalanceAccountBalances$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AccountAttributesEarningsBalanceAccountBalances' from JSON`,
  );
}

/** @internal */
export const AccountAttributesEarningsBalanceAccountCapabilities$inboundSchema:
  z.ZodType<
    AccountAttributesEarningsBalanceAccountCapabilities,
    z.ZodTypeDef,
    unknown
  > = z.object({
    transfer_destination: z.array(TransferDestinationCapability$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "transfer_destination": "transferDestination",
    });
  });

export function accountAttributesEarningsBalanceAccountCapabilitiesFromJSON(
  jsonString: string,
): SafeParseResult<
  AccountAttributesEarningsBalanceAccountCapabilities,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesEarningsBalanceAccountCapabilities$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AccountAttributesEarningsBalanceAccountCapabilities' from JSON`,
  );
}

/** @internal */
export const Details$inboundSchema: z.ZodType<Details, z.ZodTypeDef, unknown> =
  z.object({});

export function detailsFromJSON(
  jsonString: string,
): SafeParseResult<Details, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Details$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Details' from JSON`,
  );
}

/** @internal */
export const EarningsBalanceReadOnly$inboundSchema: z.ZodType<
  EarningsBalanceReadOnly,
  z.ZodTypeDef,
  unknown
> = z.object({
  verification_status:
    AccountAttributesEarningsBalanceVerificationStatus$inboundSchema,
  balances: z.lazy(() =>
    AccountAttributesEarningsBalanceAccountBalances$inboundSchema
  ),
  capabilities: z.lazy(() =>
    AccountAttributesEarningsBalanceAccountCapabilities$inboundSchema
  ),
  name: z.string(),
  account_type: z.literal("EARNINGS_BALANCE"),
  subtype: z.literal("ODP"),
  details: z.lazy(() => Details$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "verification_status": "verificationStatus",
    "balances": "accountBalances",
    "capabilities": "accountCapabilities",
    "account_type": "accountType",
  });
});

export function earningsBalanceReadOnlyFromJSON(
  jsonString: string,
): SafeParseResult<EarningsBalanceReadOnly, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EarningsBalanceReadOnly$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EarningsBalanceReadOnly' from JSON`,
  );
}

/** @internal */
export const AccountAttributesCardVerificationStatus$inboundSchema:
  z.ZodNativeEnum<typeof AccountAttributesCardVerificationStatus> = z
    .nativeEnum(AccountAttributesCardVerificationStatus);

/** @internal */
export const AccountAttributesCardAccountBalances$inboundSchema: z.ZodType<
  AccountAttributesCardAccountBalances,
  z.ZodTypeDef,
  unknown
> = z.object({
  available: z.nullable(z.number().int()),
  current: z.nullable(z.number().int()),
  currency: z.string(),
});

export function accountAttributesCardAccountBalancesFromJSON(
  jsonString: string,
): SafeParseResult<AccountAttributesCardAccountBalances, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesCardAccountBalances$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AccountAttributesCardAccountBalances' from JSON`,
  );
}

/** @internal */
export const AccountAttributesCardAccountCapabilities$inboundSchema: z.ZodType<
  AccountAttributesCardAccountCapabilities,
  z.ZodTypeDef,
  unknown
> = z.object({
  transfer_destination: z.array(TransferDestinationCapability$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "transfer_destination": "transferDestination",
  });
});

export function accountAttributesCardAccountCapabilitiesFromJSON(
  jsonString: string,
): SafeParseResult<
  AccountAttributesCardAccountCapabilities,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AccountAttributesCardAccountCapabilities$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AccountAttributesCardAccountCapabilities' from JSON`,
  );
}

/** @internal */
export const AccountAttributesCardSubtype$inboundSchema: z.ZodNativeEnum<
  typeof AccountAttributesCardSubtype
> = z.nativeEnum(AccountAttributesCardSubtype);
/** @internal */
export const AccountAttributesCardSubtype$outboundSchema: z.ZodNativeEnum<
  typeof AccountAttributesCardSubtype
> = AccountAttributesCardSubtype$inboundSchema;

/** @internal */
export const CardAccountDetailsOutput$inboundSchema: z.ZodType<
  CardAccountDetailsOutput,
  z.ZodTypeDef,
  unknown
> = z.object({
  last_four: z.string(),
  issuer: z.string(),
  first_name: z.string(),
  last_name: z.string(),
  expiration_month: z.string(),
  expiration_year: z.string(),
}).transform((v) => {
  return remap$(v, {
    "last_four": "lastFour",
    "first_name": "firstName",
    "last_name": "lastName",
    "expiration_month": "expirationMonth",
    "expiration_year": "expirationYear",
  });
});

export function cardAccountDetailsOutputFromJSON(
  jsonString: string,
): SafeParseResult<CardAccountDetailsOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CardAccountDetailsOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CardAccountDetailsOutput' from JSON`,
  );
}

/** @internal */
export const CardOutput$inboundSchema: z.ZodType<
  CardOutput,
  z.ZodTypeDef,
  unknown
> = z.object({
  verification_status: AccountAttributesCardVerificationStatus$inboundSchema,
  balances: z.lazy(() => AccountAttributesCardAccountBalances$inboundSchema),
  capabilities: z.lazy(() =>
    AccountAttributesCardAccountCapabilities$inboundSchema
  ),
  name: z.string(),
  account_type: z.literal("CARD"),
  subtype: AccountAttributesCardSubtype$inboundSchema,
  details: z.lazy(() => CardAccountDetailsOutput$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "verification_status": "verificationStatus",
    "balances": "accountBalances",
    "capabilities": "accountCapabilities",
    "account_type": "accountType",
    "details": "cardAccountDetails",
  });
});

export function cardOutputFromJSON(
  jsonString: string,
): SafeParseResult<CardOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CardOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CardOutput' from JSON`,
  );
}

/** @internal */
export const AccountAttributesOutput$inboundSchema: z.ZodType<
  AccountAttributesOutput,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CardOutput$inboundSchema),
  z.lazy(() => EarningsBalanceReadOnly$inboundSchema),
  z.lazy(() => Depository$inboundSchema),
]);

export function accountAttributesOutputFromJSON(
  jsonString: string,
): SafeParseResult<AccountAttributesOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AccountAttributesOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AccountAttributesOutput' from JSON`,
  );
}

/** @internal */
export type DepositoryInput$Outbound = {
  name: string;
  account_type: "DEPOSITORY";
  subtype: string;
  details: DepositoryAccountDetails$Outbound;
};

/** @internal */
export const DepositoryInput$outboundSchema: z.ZodType<
  DepositoryInput$Outbound,
  z.ZodTypeDef,
  DepositoryInput
> = z.object({
  name: z.string(),
  accountType: z.literal("DEPOSITORY"),
  subtype: AccountAttributesDepositorySubtype$outboundSchema,
  depositoryAccountDetails: z.lazy(() =>
    DepositoryAccountDetails$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    accountType: "account_type",
    depositoryAccountDetails: "details",
  });
});

export function depositoryInputToJSON(
  depositoryInput: DepositoryInput,
): string {
  return JSON.stringify(DepositoryInput$outboundSchema.parse(depositoryInput));
}

/** @internal */
export type EarningsBalanceReadOnlyInput$Outbound = {};

/** @internal */
export const EarningsBalanceReadOnlyInput$outboundSchema: z.ZodType<
  EarningsBalanceReadOnlyInput$Outbound,
  z.ZodTypeDef,
  EarningsBalanceReadOnlyInput
> = z.object({});

export function earningsBalanceReadOnlyInputToJSON(
  earningsBalanceReadOnlyInput: EarningsBalanceReadOnlyInput,
): string {
  return JSON.stringify(
    EarningsBalanceReadOnlyInput$outboundSchema.parse(
      earningsBalanceReadOnlyInput,
    ),
  );
}

/** @internal */
export type CardAccountDetailsInput$Outbound = {
  token: string;
  issuer: string;
  first_name: string;
  last_name: string;
  expiration_month: string;
  expiration_year: string;
  address_line_one: string;
  address_line_two?: string | undefined;
  address_city: string;
  address_state: string;
  address_zip_code: string;
  address_country: string;
};

/** @internal */
export const CardAccountDetailsInput$outboundSchema: z.ZodType<
  CardAccountDetailsInput$Outbound,
  z.ZodTypeDef,
  CardAccountDetailsInput
> = z.object({
  token: z.string(),
  issuer: z.string(),
  firstName: z.string(),
  lastName: z.string(),
  expirationMonth: z.string(),
  expirationYear: z.string(),
  addressLineOne: z.string(),
  addressLineTwo: z.string().optional(),
  addressCity: z.string(),
  addressState: z.string(),
  addressZipCode: z.string(),
  addressCountry: z.string(),
}).transform((v) => {
  return remap$(v, {
    firstName: "first_name",
    lastName: "last_name",
    expirationMonth: "expiration_month",
    expirationYear: "expiration_year",
    addressLineOne: "address_line_one",
    addressLineTwo: "address_line_two",
    addressCity: "address_city",
    addressState: "address_state",
    addressZipCode: "address_zip_code",
    addressCountry: "address_country",
  });
});

export function cardAccountDetailsInputToJSON(
  cardAccountDetailsInput: CardAccountDetailsInput,
): string {
  return JSON.stringify(
    CardAccountDetailsInput$outboundSchema.parse(cardAccountDetailsInput),
  );
}

/** @internal */
export type CardInput$Outbound = {
  name: string;
  account_type: "CARD";
  subtype: string;
  details: CardAccountDetailsInput$Outbound;
};

/** @internal */
export const CardInput$outboundSchema: z.ZodType<
  CardInput$Outbound,
  z.ZodTypeDef,
  CardInput
> = z.object({
  name: z.string(),
  accountType: z.literal("CARD"),
  subtype: AccountAttributesCardSubtype$outboundSchema,
  cardAccountDetails: z.lazy(() => CardAccountDetailsInput$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    accountType: "account_type",
    cardAccountDetails: "details",
  });
});

export function cardInputToJSON(cardInput: CardInput): string {
  return JSON.stringify(CardInput$outboundSchema.parse(cardInput));
}

/** @internal */
export type AccountAttributesInput$Outbound =
  | CardInput$Outbound
  | DepositoryInput$Outbound
  | EarningsBalanceReadOnlyInput$Outbound;

/** @internal */
export const AccountAttributesInput$outboundSchema: z.ZodType<
  AccountAttributesInput$Outbound,
  z.ZodTypeDef,
  AccountAttributesInput
> = z.union([
  z.lazy(() => CardInput$outboundSchema),
  z.lazy(() => DepositoryInput$outboundSchema),
  z.lazy(() => EarningsBalanceReadOnlyInput$outboundSchema),
]);

export function accountAttributesInputToJSON(
  accountAttributesInput: AccountAttributesInput,
): string {
  return JSON.stringify(
    AccountAttributesInput$outboundSchema.parse(accountAttributesInput),
  );
}
