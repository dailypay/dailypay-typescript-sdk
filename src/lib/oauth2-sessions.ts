/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export type OAuth2Session = {
  token: string;
  expiresAt?: number; // Unix timestamp in milliseconds. If undefined, token never expires
  scopes: string[]; // OAuth2 scopes requested when obtaining this token
};

export class OAuth2SessionStore {
  cache: Map<string, Map<string, OAuth2Session>> = new Map();

  getSession(
    ownerKey: string,
    scopes: string[],
  ): OAuth2Session | undefined {
    const tokens = this.cache.get(ownerKey);
    if (!tokens) {
      return;
    }

    const scopeKey = this.#getScopesKey(scopes);

    // First look for an exact match
    const exactMatch = tokens.get(scopeKey);
    if (
      exactMatch !== undefined && !this.#hasTokenExpired(exactMatch.expiresAt)
    ) {
      return exactMatch;
    }

    // If no exact match was found or it was expired, look for a superset match
    for (const [_, session] of tokens) {
      if (
        this.#hasRequiredScopes(session.scopes, scopes)
        && !this.#hasTokenExpired(session.expiresAt)
      ) {
        return session;
      }
    }

    return undefined;
  }

  storeSession(
    ownerKey: string,
    scopes: string[],
    entry: OAuth2Session,
  ): void {
    let tokens = this.cache.get(ownerKey);
    if (tokens == null) {
      tokens = new Map<string, OAuth2Session>();
      this.cache.set(ownerKey, tokens);
    }

    tokens.set(this.#getScopesKey(scopes), entry);
  }

  deleteSession(
    ownerKey: string,
    scopes: string[],
  ): OAuth2Session | undefined {
    const tokens = this.cache.get(ownerKey);
    if (!tokens) {
      return;
    }

    const scopeKey = this.#getScopesKey(scopes);
    const outgoing = tokens.get(scopeKey);
    tokens.delete(scopeKey);

    // Clean up empty owner maps
    if (tokens.size === 0) {
      this.cache.delete(ownerKey);
    }

    return outgoing;
  }

  statistics(): {
    total: number;
    active: number;
    expired: number;
  } {
    let total = 0;
    let active = 0;
    let expired = 0;

    for (const [_, sessions] of this.cache) {
      for (const [_, session] of sessions) {
        total += 1;

        if (this.#hasTokenExpired(session.expiresAt)) {
          expired += 1;
        } else {
          active += 1;
        }
      }
    }

    return { total, active, expired };
  }

  #getScopesKey(scopes: string[]): string {
    if (!scopes?.length) {
      return "";
    }

    const p = new URLSearchParams();
    const sorted = scopes.slice().sort();
    for (const scope of sorted) {
      p.append("s", scope);
    }

    return p.toString();
  }

  #hasRequiredScopes(
    sessionScopes: string[],
    requiredScopes: string[],
  ): boolean {
    // If no scopes are required, any token works
    if (requiredScopes.length === 0) {
      return true;
    }

    // Check if session has all required scopes
    const sessionScopeSet = new Set(sessionScopes);
    for (const requiredScope of requiredScopes) {
      if (!sessionScopeSet.has(requiredScope)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Checks if the token has expired.
   * If no `expiresAt` is present, the token is considered to never expire.
   * A 60-second buffer is applied to refresh tokens before they actually expire.
   */
  #hasTokenExpired(expiresAt: number | undefined): boolean {
    return expiresAt !== undefined && Date.now() + 60000 >= expiresAt;
  }
}
