// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type RefreshToken struct {
	// The OAuth2 grant type
	GrantType string `form:"name=grant_type"`
	// A refresh token received from a previous token request
	RefreshToken string `form:"name=refresh_token"`
	// The client id of the application requesting the token.
	ClientID string `form:"name=client_id"`
	// The client secret of the application requesting the token, if available.
	ClientSecret *string `form:"name=client_secret"`
}

func (o *RefreshToken) GetGrantType() string {
	if o == nil {
		return ""
	}
	return o.GrantType
}

func (o *RefreshToken) GetRefreshToken() string {
	if o == nil {
		return ""
	}
	return o.RefreshToken
}

func (o *RefreshToken) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *RefreshToken) GetClientSecret() *string {
	if o == nil {
		return nil
	}
	return o.ClientSecret
}

type ClientCredentialsFlow struct {
	// The OAuth2 grant type
	GrantType string `form:"name=grant_type"`
	// A space-separated list of scopes to request
	Scope string `form:"name=scope"`
	// The client id of the application requesting the token.
	ClientID string `form:"name=client_id"`
	// The client secret of the application requesting the token.
	ClientSecret string `form:"name=client_secret"`
}

func (o *ClientCredentialsFlow) GetGrantType() string {
	if o == nil {
		return ""
	}
	return o.GrantType
}

func (o *ClientCredentialsFlow) GetScope() string {
	if o == nil {
		return ""
	}
	return o.Scope
}

func (o *ClientCredentialsFlow) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *ClientCredentialsFlow) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

// GrantType - The OAuth2 grant type
type GrantType string

const (
	GrantTypeAuthorizationCode GrantType = "authorization_code"
)

func (e GrantType) ToPointer() *GrantType {
	return &e
}
func (e *GrantType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "authorization_code":
		*e = GrantType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GrantType: %v", v)
	}
}

type AuthorizationCodeFlow struct {
	// The OAuth2 grant type
	GrantType GrantType `form:"name=grant_type"`
	// An authorization code received through user authorization flow
	Code string `form:"name=code"`
	// The url redirected to after the authorization flow was completed by current user.
	RedirectURI string `form:"name=redirect_uri"`
	// A value used by the client to maintain state between the request and callback. This is used to prevent CSRF attacks.  See https://www.rfc-editor.org/rfc/rfc6749#section-10.12 for more detail.
	State string `form:"name=state"`
	// A PKCE verifier matching the challenge submitted during the authorization code request.
	CodeVerifier *string `form:"name=code_verifier"`
	// The client id of the application requesting the token.
	ClientID string `form:"name=client_id"`
	// The client secret of the application requesting the token, if available.
	ClientSecret *string `form:"name=client_secret"`
}

func (o *AuthorizationCodeFlow) GetGrantType() GrantType {
	if o == nil {
		return GrantType("")
	}
	return o.GrantType
}

func (o *AuthorizationCodeFlow) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *AuthorizationCodeFlow) GetRedirectURI() string {
	if o == nil {
		return ""
	}
	return o.RedirectURI
}

func (o *AuthorizationCodeFlow) GetState() string {
	if o == nil {
		return ""
	}
	return o.State
}

func (o *AuthorizationCodeFlow) GetCodeVerifier() *string {
	if o == nil {
		return nil
	}
	return o.CodeVerifier
}

func (o *AuthorizationCodeFlow) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *AuthorizationCodeFlow) GetClientSecret() *string {
	if o == nil {
		return nil
	}
	return o.ClientSecret
}

type RequestTokenRequestType string

const (
	RequestTokenRequestTypeAuthorizationCodeFlow RequestTokenRequestType = "Authorization code flow"
	RequestTokenRequestTypeClientCredentialsFlow RequestTokenRequestType = "Client credentials flow"
	RequestTokenRequestTypeRefreshToken          RequestTokenRequestType = "Refresh token"
)

type RequestTokenRequest struct {
	AuthorizationCodeFlow *AuthorizationCodeFlow `queryParam:"inline"`
	ClientCredentialsFlow *ClientCredentialsFlow `queryParam:"inline"`
	RefreshToken          *RefreshToken          `queryParam:"inline"`

	Type RequestTokenRequestType
}

func CreateRequestTokenRequestAuthorizationCodeFlow(authorizationCodeFlow AuthorizationCodeFlow) RequestTokenRequest {
	typ := RequestTokenRequestTypeAuthorizationCodeFlow

	return RequestTokenRequest{
		AuthorizationCodeFlow: &authorizationCodeFlow,
		Type:                  typ,
	}
}

func CreateRequestTokenRequestClientCredentialsFlow(clientCredentialsFlow ClientCredentialsFlow) RequestTokenRequest {
	typ := RequestTokenRequestTypeClientCredentialsFlow

	return RequestTokenRequest{
		ClientCredentialsFlow: &clientCredentialsFlow,
		Type:                  typ,
	}
}

func CreateRequestTokenRequestRefreshToken(refreshToken RefreshToken) RequestTokenRequest {
	typ := RequestTokenRequestTypeRefreshToken

	return RequestTokenRequest{
		RefreshToken: &refreshToken,
		Type:         typ,
	}
}

func (u *RequestTokenRequest) UnmarshalJSON(data []byte) error {

	var clientCredentialsFlow ClientCredentialsFlow = ClientCredentialsFlow{}
	if err := utils.UnmarshalJSON(data, &clientCredentialsFlow, "", true, true); err == nil {
		u.ClientCredentialsFlow = &clientCredentialsFlow
		u.Type = RequestTokenRequestTypeClientCredentialsFlow
		return nil
	}

	var refreshToken RefreshToken = RefreshToken{}
	if err := utils.UnmarshalJSON(data, &refreshToken, "", true, true); err == nil {
		u.RefreshToken = &refreshToken
		u.Type = RequestTokenRequestTypeRefreshToken
		return nil
	}

	var authorizationCodeFlow AuthorizationCodeFlow = AuthorizationCodeFlow{}
	if err := utils.UnmarshalJSON(data, &authorizationCodeFlow, "", true, true); err == nil {
		u.AuthorizationCodeFlow = &authorizationCodeFlow
		u.Type = RequestTokenRequestTypeAuthorizationCodeFlow
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RequestTokenRequest", string(data))
}

func (u RequestTokenRequest) MarshalJSON() ([]byte, error) {
	if u.AuthorizationCodeFlow != nil {
		return utils.MarshalJSON(u.AuthorizationCodeFlow, "", true)
	}

	if u.ClientCredentialsFlow != nil {
		return utils.MarshalJSON(u.ClientCredentialsFlow, "", true)
	}

	if u.RefreshToken != nil {
		return utils.MarshalJSON(u.RefreshToken, "", true)
	}

	return nil, errors.New("could not marshal union type RequestTokenRequest: all fields are null")
}

// ErrorCode - Error code indicating what went wrong with the oauth token exchange. See the OAuth2 RFC for further context https://datatracker.ietf.org/doc/html/rfc6749#section-5.2
type ErrorCode string

const (
	ErrorCodeInvalidRequest       ErrorCode = "invalid_request"
	ErrorCodeInvalidClient        ErrorCode = "invalid_client"
	ErrorCodeInvalidGrant         ErrorCode = "invalid_grant"
	ErrorCodeUnauthorizedClient   ErrorCode = "unauthorized_client"
	ErrorCodeUnsupportedGrantType ErrorCode = "unsupported_grant_type"
)

func (e ErrorCode) ToPointer() *ErrorCode {
	return &e
}
func (e *ErrorCode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "invalid_request":
		fallthrough
	case "invalid_client":
		fallthrough
	case "invalid_grant":
		fallthrough
	case "unauthorized_client":
		fallthrough
	case "unsupported_grant_type":
		*e = ErrorCode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ErrorCode: %v", v)
	}
}

type RequestTokenResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// DailyPay user access token
	TokenData *components.TokenData
}

func (o *RequestTokenResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *RequestTokenResponse) GetTokenData() *components.TokenData {
	if o == nil {
		return nil
	}
	return o.TokenData
}
