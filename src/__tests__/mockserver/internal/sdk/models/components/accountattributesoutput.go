// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

// AccountAttributesDepositoryVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesDepositoryVerificationStatus string

const (
	AccountAttributesDepositoryVerificationStatusVerificationPending AccountAttributesDepositoryVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesDepositoryVerificationStatusVerificationFailed  AccountAttributesDepositoryVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesDepositoryVerificationStatusVerified            AccountAttributesDepositoryVerificationStatus = "VERIFIED"
)

func (e AccountAttributesDepositoryVerificationStatus) ToPointer() *AccountAttributesDepositoryVerificationStatus {
	return &e
}
func (e *AccountAttributesDepositoryVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesDepositoryVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesDepositoryVerificationStatus: %v", v)
	}
}

type AccountAttributesDepositoryAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	//
	// **Special note for earnings_balance-type accounts:**
	// During a typical pay period, if a user transfers no money from an earnings_balance-type account to a personal account,
	// the `current` balance will generally be 0, because transfers from earnings to this account will be
	// PENDING until the paycheck related to those earnings is processed.
	// Pending inflows are included in the `available` balance, not the `current` balance.
	//
	// If a user transfers money from an earnings_balance-type account to a personal account,
	// the `current` balance will be negative as those transfers settle. When a paycheck is processed,
	// DailyPay will automatically attempt to zero out the balance,
	// transferring any remaining funds to the `default_paycheck_destination` set for the associated Job.
	//
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,
	// which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (o *AccountAttributesDepositoryAccountBalances) GetAvailable() *int64 {
	if o == nil {
		return nil
	}
	return o.Available
}

func (o *AccountAttributesDepositoryAccountBalances) GetCurrent() *int64 {
	if o == nil {
		return nil
	}
	return o.Current
}

func (o *AccountAttributesDepositoryAccountBalances) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

type AccountAttributesDepositoryAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (o *AccountAttributesDepositoryAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if o == nil {
		return []TransferDestinationCapability{}
	}
	return o.TransferDestination
}

// AccountAttributesDepositorySubtype - The subtype of the account.
type AccountAttributesDepositorySubtype string

const (
	AccountAttributesDepositorySubtypeSavings  AccountAttributesDepositorySubtype = "SAVINGS"
	AccountAttributesDepositorySubtypeChecking AccountAttributesDepositorySubtype = "CHECKING"
)

func (e AccountAttributesDepositorySubtype) ToPointer() *AccountAttributesDepositorySubtype {
	return &e
}
func (e *AccountAttributesDepositorySubtype) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SAVINGS":
		fallthrough
	case "CHECKING":
		*e = AccountAttributesDepositorySubtype(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesDepositorySubtype: %v", v)
	}
}

// DepositoryAccountDetails - The banking details of the account and account holder.
type DepositoryAccountDetails struct {
	// The first name of the account holder.
	FirstName string `json:"first_name"`
	// The last name of the account holder.
	LastName string `json:"last_name"`
	// The routing number of the bank that holds this account. Responses from this API that return this number are masked to the last four digits.
	RoutingNumber string `json:"routing_number"`
	// The account number. Responses from this API that return this number are masked to the last four digits.
	AccountNumber string `json:"account_number"`
}

func (o *DepositoryAccountDetails) GetFirstName() string {
	if o == nil {
		return ""
	}
	return o.FirstName
}

func (o *DepositoryAccountDetails) GetLastName() string {
	if o == nil {
		return ""
	}
	return o.LastName
}

func (o *DepositoryAccountDetails) GetRoutingNumber() string {
	if o == nil {
		return ""
	}
	return o.RoutingNumber
}

func (o *DepositoryAccountDetails) GetAccountNumber() string {
	if o == nil {
		return ""
	}
	return o.AccountNumber
}

// Depository - An account with type `DEPOSITORY` and subtype `SAVINGS` or `CHECKING`.
type Depository struct {
	// A code that indicates the status of an account that is a destination for funds.
	VerificationStatus  AccountAttributesDepositoryVerificationStatus  `json:"verification_status"`
	AccountBalances     AccountAttributesDepositoryAccountBalances     `json:"balances"`
	AccountCapabilities AccountAttributesDepositoryAccountCapabilities `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"DEPOSITORY" json:"account_type"`
	// The subtype of the account.
	Subtype AccountAttributesDepositorySubtype `json:"subtype"`
	// The banking details of the account and account holder.
	DepositoryAccountDetails DepositoryAccountDetails `json:"details"`
}

func (d Depository) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Depository) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *Depository) GetVerificationStatus() AccountAttributesDepositoryVerificationStatus {
	if o == nil {
		return AccountAttributesDepositoryVerificationStatus("")
	}
	return o.VerificationStatus
}

func (o *Depository) GetAccountBalances() AccountAttributesDepositoryAccountBalances {
	if o == nil {
		return AccountAttributesDepositoryAccountBalances{}
	}
	return o.AccountBalances
}

func (o *Depository) GetAccountCapabilities() AccountAttributesDepositoryAccountCapabilities {
	if o == nil {
		return AccountAttributesDepositoryAccountCapabilities{}
	}
	return o.AccountCapabilities
}

func (o *Depository) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Depository) GetAccountType() string {
	return "DEPOSITORY"
}

func (o *Depository) GetSubtype() AccountAttributesDepositorySubtype {
	if o == nil {
		return AccountAttributesDepositorySubtype("")
	}
	return o.Subtype
}

func (o *Depository) GetDepositoryAccountDetails() DepositoryAccountDetails {
	if o == nil {
		return DepositoryAccountDetails{}
	}
	return o.DepositoryAccountDetails
}

// AccountAttributesEarningsBalanceVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesEarningsBalanceVerificationStatus string

const (
	AccountAttributesEarningsBalanceVerificationStatusVerificationPending AccountAttributesEarningsBalanceVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesEarningsBalanceVerificationStatusVerificationFailed  AccountAttributesEarningsBalanceVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesEarningsBalanceVerificationStatusVerified            AccountAttributesEarningsBalanceVerificationStatus = "VERIFIED"
)

func (e AccountAttributesEarningsBalanceVerificationStatus) ToPointer() *AccountAttributesEarningsBalanceVerificationStatus {
	return &e
}
func (e *AccountAttributesEarningsBalanceVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesEarningsBalanceVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesEarningsBalanceVerificationStatus: %v", v)
	}
}

type AccountAttributesEarningsBalanceAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	//
	// **Special note for earnings_balance-type accounts:**
	// During a typical pay period, if a user transfers no money from an earnings_balance-type account to a personal account,
	// the `current` balance will generally be 0, because transfers from earnings to this account will be
	// PENDING until the paycheck related to those earnings is processed.
	// Pending inflows are included in the `available` balance, not the `current` balance.
	//
	// If a user transfers money from an earnings_balance-type account to a personal account,
	// the `current` balance will be negative as those transfers settle. When a paycheck is processed,
	// DailyPay will automatically attempt to zero out the balance,
	// transferring any remaining funds to the `default_paycheck_destination` set for the associated Job.
	//
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,
	// which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (o *AccountAttributesEarningsBalanceAccountBalances) GetAvailable() *int64 {
	if o == nil {
		return nil
	}
	return o.Available
}

func (o *AccountAttributesEarningsBalanceAccountBalances) GetCurrent() *int64 {
	if o == nil {
		return nil
	}
	return o.Current
}

func (o *AccountAttributesEarningsBalanceAccountBalances) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

type AccountAttributesEarningsBalanceAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (o *AccountAttributesEarningsBalanceAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if o == nil {
		return []TransferDestinationCapability{}
	}
	return o.TransferDestination
}

// AccountAttributesEarningsBalanceDetails - An empty object for earnings balance accounts.
type AccountAttributesEarningsBalanceDetails struct {
}

// EarningsBalanceReadOnly - An account with type `EARNINGS_BALANCE` and subtype `ODP`.
type EarningsBalanceReadOnly struct {
	// A code that indicates the status of an account that is a destination for funds.
	VerificationStatus  AccountAttributesEarningsBalanceVerificationStatus  `json:"verification_status"`
	AccountBalances     AccountAttributesEarningsBalanceAccountBalances     `json:"balances"`
	AccountCapabilities AccountAttributesEarningsBalanceAccountCapabilities `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"EARNINGS_BALANCE" json:"account_type"`
	// The subtype of the account.
	subtype string `const:"ODP" json:"subtype"`
	// An empty object for earnings balance accounts.
	Details AccountAttributesEarningsBalanceDetails `json:"details"`
}

func (e EarningsBalanceReadOnly) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EarningsBalanceReadOnly) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *EarningsBalanceReadOnly) GetVerificationStatus() AccountAttributesEarningsBalanceVerificationStatus {
	if o == nil {
		return AccountAttributesEarningsBalanceVerificationStatus("")
	}
	return o.VerificationStatus
}

func (o *EarningsBalanceReadOnly) GetAccountBalances() AccountAttributesEarningsBalanceAccountBalances {
	if o == nil {
		return AccountAttributesEarningsBalanceAccountBalances{}
	}
	return o.AccountBalances
}

func (o *EarningsBalanceReadOnly) GetAccountCapabilities() AccountAttributesEarningsBalanceAccountCapabilities {
	if o == nil {
		return AccountAttributesEarningsBalanceAccountCapabilities{}
	}
	return o.AccountCapabilities
}

func (o *EarningsBalanceReadOnly) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *EarningsBalanceReadOnly) GetAccountType() string {
	return "EARNINGS_BALANCE"
}

func (o *EarningsBalanceReadOnly) GetSubtype() string {
	return "ODP"
}

func (o *EarningsBalanceReadOnly) GetDetails() AccountAttributesEarningsBalanceDetails {
	if o == nil {
		return AccountAttributesEarningsBalanceDetails{}
	}
	return o.Details
}

// AccountAttributesCardVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesCardVerificationStatus string

const (
	AccountAttributesCardVerificationStatusVerificationPending AccountAttributesCardVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesCardVerificationStatusVerificationFailed  AccountAttributesCardVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesCardVerificationStatusVerified            AccountAttributesCardVerificationStatus = "VERIFIED"
)

func (e AccountAttributesCardVerificationStatus) ToPointer() *AccountAttributesCardVerificationStatus {
	return &e
}
func (e *AccountAttributesCardVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesCardVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesCardVerificationStatus: %v", v)
	}
}

type AccountAttributesCardAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	//
	// **Special note for earnings_balance-type accounts:**
	// During a typical pay period, if a user transfers no money from an earnings_balance-type account to a personal account,
	// the `current` balance will generally be 0, because transfers from earnings to this account will be
	// PENDING until the paycheck related to those earnings is processed.
	// Pending inflows are included in the `available` balance, not the `current` balance.
	//
	// If a user transfers money from an earnings_balance-type account to a personal account,
	// the `current` balance will be negative as those transfers settle. When a paycheck is processed,
	// DailyPay will automatically attempt to zero out the balance,
	// transferring any remaining funds to the `default_paycheck_destination` set for the associated Job.
	//
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,
	// which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (o *AccountAttributesCardAccountBalances) GetAvailable() *int64 {
	if o == nil {
		return nil
	}
	return o.Available
}

func (o *AccountAttributesCardAccountBalances) GetCurrent() *int64 {
	if o == nil {
		return nil
	}
	return o.Current
}

func (o *AccountAttributesCardAccountBalances) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

type AccountAttributesCardAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (o *AccountAttributesCardAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if o == nil {
		return []TransferDestinationCapability{}
	}
	return o.TransferDestination
}

// AccountAttributesCardSubtype - The subtype of the account.
type AccountAttributesCardSubtype string

const (
	AccountAttributesCardSubtypeDebit   AccountAttributesCardSubtype = "DEBIT"
	AccountAttributesCardSubtypeGalileo AccountAttributesCardSubtype = "GALILEO"
	AccountAttributesCardSubtypeWisely  AccountAttributesCardSubtype = "WISELY"
)

func (e AccountAttributesCardSubtype) ToPointer() *AccountAttributesCardSubtype {
	return &e
}
func (e *AccountAttributesCardSubtype) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DEBIT":
		fallthrough
	case "GALILEO":
		fallthrough
	case "WISELY":
		*e = AccountAttributesCardSubtype(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesCardSubtype: %v", v)
	}
}

type DetailsOutputType string

const (
	DetailsOutputTypeAccountDebitCardOutput   DetailsOutputType = "Account_DebitCard_output"
	DetailsOutputTypeAccountGalileoCardOutput DetailsOutputType = "Account_GalileoCard_output"
	DetailsOutputTypeAccountWiselyCardOutput  DetailsOutputType = "Account_WiselyCard_output"
)

// DetailsOutput - The banking details of the account and account holder.
type DetailsOutput struct {
	AccountDebitCardOutput   *AccountDebitCardOutput   `queryParam:"inline"`
	AccountGalileoCardOutput *AccountGalileoCardOutput `queryParam:"inline"`
	AccountWiselyCardOutput  *AccountWiselyCardOutput  `queryParam:"inline"`

	Type DetailsOutputType
}

func CreateDetailsOutputAccountDebitCardOutput(accountDebitCardOutput AccountDebitCardOutput) DetailsOutput {
	typ := DetailsOutputTypeAccountDebitCardOutput

	return DetailsOutput{
		AccountDebitCardOutput: &accountDebitCardOutput,
		Type:                   typ,
	}
}

func CreateDetailsOutputAccountGalileoCardOutput(accountGalileoCardOutput AccountGalileoCardOutput) DetailsOutput {
	typ := DetailsOutputTypeAccountGalileoCardOutput

	return DetailsOutput{
		AccountGalileoCardOutput: &accountGalileoCardOutput,
		Type:                     typ,
	}
}

func CreateDetailsOutputAccountWiselyCardOutput(accountWiselyCardOutput AccountWiselyCardOutput) DetailsOutput {
	typ := DetailsOutputTypeAccountWiselyCardOutput

	return DetailsOutput{
		AccountWiselyCardOutput: &accountWiselyCardOutput,
		Type:                    typ,
	}
}

func (u *DetailsOutput) UnmarshalJSON(data []byte) error {

	var accountDebitCardOutput AccountDebitCardOutput = AccountDebitCardOutput{}
	if err := utils.UnmarshalJSON(data, &accountDebitCardOutput, "", true, true); err == nil {
		u.AccountDebitCardOutput = &accountDebitCardOutput
		u.Type = DetailsOutputTypeAccountDebitCardOutput
		return nil
	}

	var accountGalileoCardOutput AccountGalileoCardOutput = AccountGalileoCardOutput{}
	if err := utils.UnmarshalJSON(data, &accountGalileoCardOutput, "", true, true); err == nil {
		u.AccountGalileoCardOutput = &accountGalileoCardOutput
		u.Type = DetailsOutputTypeAccountGalileoCardOutput
		return nil
	}

	var accountWiselyCardOutput AccountWiselyCardOutput = AccountWiselyCardOutput{}
	if err := utils.UnmarshalJSON(data, &accountWiselyCardOutput, "", true, true); err == nil {
		u.AccountWiselyCardOutput = &accountWiselyCardOutput
		u.Type = DetailsOutputTypeAccountWiselyCardOutput
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DetailsOutput", string(data))
}

func (u DetailsOutput) MarshalJSON() ([]byte, error) {
	if u.AccountDebitCardOutput != nil {
		return utils.MarshalJSON(u.AccountDebitCardOutput, "", true)
	}

	if u.AccountGalileoCardOutput != nil {
		return utils.MarshalJSON(u.AccountGalileoCardOutput, "", true)
	}

	if u.AccountWiselyCardOutput != nil {
		return utils.MarshalJSON(u.AccountWiselyCardOutput, "", true)
	}

	return nil, errors.New("could not marshal union type DetailsOutput: all fields are null")
}

// CardOutput - An account with type `CARD` and subtype `GALILEO`, `WISELY`, or `DEBIT`.
type CardOutput struct {
	// A code that indicates the status of an account that is a destination for funds.
	VerificationStatus  AccountAttributesCardVerificationStatus  `json:"verification_status"`
	AccountBalances     AccountAttributesCardAccountBalances     `json:"balances"`
	AccountCapabilities AccountAttributesCardAccountCapabilities `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"CARD" json:"account_type"`
	// The subtype of the account.
	Subtype AccountAttributesCardSubtype `json:"subtype"`
	// The banking details of the account and account holder.
	Details DetailsOutput `json:"details"`
}

func (c CardOutput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CardOutput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *CardOutput) GetVerificationStatus() AccountAttributesCardVerificationStatus {
	if o == nil {
		return AccountAttributesCardVerificationStatus("")
	}
	return o.VerificationStatus
}

func (o *CardOutput) GetAccountBalances() AccountAttributesCardAccountBalances {
	if o == nil {
		return AccountAttributesCardAccountBalances{}
	}
	return o.AccountBalances
}

func (o *CardOutput) GetAccountCapabilities() AccountAttributesCardAccountCapabilities {
	if o == nil {
		return AccountAttributesCardAccountCapabilities{}
	}
	return o.AccountCapabilities
}

func (o *CardOutput) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CardOutput) GetAccountType() string {
	return "CARD"
}

func (o *CardOutput) GetSubtype() AccountAttributesCardSubtype {
	if o == nil {
		return AccountAttributesCardSubtype("")
	}
	return o.Subtype
}

func (o *CardOutput) GetDetails() DetailsOutput {
	if o == nil {
		return DetailsOutput{}
	}
	return o.Details
}

type AccountAttributesOutputType string

const (
	AccountAttributesOutputTypeCardOutput              AccountAttributesOutputType = "Card_output"
	AccountAttributesOutputTypeEarningsBalanceReadOnly AccountAttributesOutputType = "Earnings Balance (read only)"
	AccountAttributesOutputTypeDepository              AccountAttributesOutputType = "Depository"
)

// AccountAttributesOutput - The details of the account.
type AccountAttributesOutput struct {
	CardOutput              *CardOutput              `queryParam:"inline"`
	EarningsBalanceReadOnly *EarningsBalanceReadOnly `queryParam:"inline"`
	Depository              *Depository              `queryParam:"inline"`

	Type AccountAttributesOutputType
}

func CreateAccountAttributesOutputCardOutput(cardOutput CardOutput) AccountAttributesOutput {
	typ := AccountAttributesOutputTypeCardOutput

	return AccountAttributesOutput{
		CardOutput: &cardOutput,
		Type:       typ,
	}
}

func CreateAccountAttributesOutputEarningsBalanceReadOnly(earningsBalanceReadOnly EarningsBalanceReadOnly) AccountAttributesOutput {
	typ := AccountAttributesOutputTypeEarningsBalanceReadOnly

	return AccountAttributesOutput{
		EarningsBalanceReadOnly: &earningsBalanceReadOnly,
		Type:                    typ,
	}
}

func CreateAccountAttributesOutputDepository(depository Depository) AccountAttributesOutput {
	typ := AccountAttributesOutputTypeDepository

	return AccountAttributesOutput{
		Depository: &depository,
		Type:       typ,
	}
}

func (u *AccountAttributesOutput) UnmarshalJSON(data []byte) error {

	var cardOutput CardOutput = CardOutput{}
	if err := utils.UnmarshalJSON(data, &cardOutput, "", true, true); err == nil {
		u.CardOutput = &cardOutput
		u.Type = AccountAttributesOutputTypeCardOutput
		return nil
	}

	var earningsBalanceReadOnly EarningsBalanceReadOnly = EarningsBalanceReadOnly{}
	if err := utils.UnmarshalJSON(data, &earningsBalanceReadOnly, "", true, true); err == nil {
		u.EarningsBalanceReadOnly = &earningsBalanceReadOnly
		u.Type = AccountAttributesOutputTypeEarningsBalanceReadOnly
		return nil
	}

	var depository Depository = Depository{}
	if err := utils.UnmarshalJSON(data, &depository, "", true, true); err == nil {
		u.Depository = &depository
		u.Type = AccountAttributesOutputTypeDepository
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccountAttributesOutput", string(data))
}

func (u AccountAttributesOutput) MarshalJSON() ([]byte, error) {
	if u.CardOutput != nil {
		return utils.MarshalJSON(u.CardOutput, "", true)
	}

	if u.EarningsBalanceReadOnly != nil {
		return utils.MarshalJSON(u.EarningsBalanceReadOnly, "", true)
	}

	if u.Depository != nil {
		return utils.MarshalJSON(u.Depository, "", true)
	}

	return nil, errors.New("could not marshal union type AccountAttributesOutput: all fields are null")
}

// DepositoryInput - An account with type `DEPOSITORY` and subtype `SAVINGS` or `CHECKING`.
type DepositoryInput struct {
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"DEPOSITORY" json:"account_type"`
	// The subtype of the account.
	Subtype AccountAttributesDepositorySubtype `json:"subtype"`
	// The banking details of the account and account holder.
	DepositoryAccountDetails DepositoryAccountDetails `json:"details"`
}

func (d DepositoryInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DepositoryInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DepositoryInput) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *DepositoryInput) GetAccountType() string {
	return "DEPOSITORY"
}

func (o *DepositoryInput) GetSubtype() AccountAttributesDepositorySubtype {
	if o == nil {
		return AccountAttributesDepositorySubtype("")
	}
	return o.Subtype
}

func (o *DepositoryInput) GetDepositoryAccountDetails() DepositoryAccountDetails {
	if o == nil {
		return DepositoryAccountDetails{}
	}
	return o.DepositoryAccountDetails
}

// EarningsBalanceReadOnlyInput - An account with type `EARNINGS_BALANCE` and subtype `ODP`.
type EarningsBalanceReadOnlyInput struct {
}

type DetailsInputType string

const (
	DetailsInputTypeAccountDebitCardInput   DetailsInputType = "Account_DebitCard_input"
	DetailsInputTypeAccountGalileoCardInput DetailsInputType = "Account_GalileoCard_input"
	DetailsInputTypeAccountWiselyCard       DetailsInputType = "Account_WiselyCard"
)

// DetailsInput - The banking details of the account and account holder.
type DetailsInput struct {
	AccountDebitCardInput   *AccountDebitCardInput   `queryParam:"inline"`
	AccountGalileoCardInput *AccountGalileoCardInput `queryParam:"inline"`
	AccountWiselyCard       *AccountWiselyCard       `queryParam:"inline"`

	Type DetailsInputType
}

func CreateDetailsInputAccountDebitCardInput(accountDebitCardInput AccountDebitCardInput) DetailsInput {
	typ := DetailsInputTypeAccountDebitCardInput

	return DetailsInput{
		AccountDebitCardInput: &accountDebitCardInput,
		Type:                  typ,
	}
}

func CreateDetailsInputAccountGalileoCardInput(accountGalileoCardInput AccountGalileoCardInput) DetailsInput {
	typ := DetailsInputTypeAccountGalileoCardInput

	return DetailsInput{
		AccountGalileoCardInput: &accountGalileoCardInput,
		Type:                    typ,
	}
}

func CreateDetailsInputAccountWiselyCard(accountWiselyCard AccountWiselyCard) DetailsInput {
	typ := DetailsInputTypeAccountWiselyCard

	return DetailsInput{
		AccountWiselyCard: &accountWiselyCard,
		Type:              typ,
	}
}

func (u *DetailsInput) UnmarshalJSON(data []byte) error {

	var accountGalileoCardInput AccountGalileoCardInput = AccountGalileoCardInput{}
	if err := utils.UnmarshalJSON(data, &accountGalileoCardInput, "", true, true); err == nil {
		u.AccountGalileoCardInput = &accountGalileoCardInput
		u.Type = DetailsInputTypeAccountGalileoCardInput
		return nil
	}

	var accountDebitCardInput AccountDebitCardInput = AccountDebitCardInput{}
	if err := utils.UnmarshalJSON(data, &accountDebitCardInput, "", true, true); err == nil {
		u.AccountDebitCardInput = &accountDebitCardInput
		u.Type = DetailsInputTypeAccountDebitCardInput
		return nil
	}

	var accountWiselyCard AccountWiselyCard = AccountWiselyCard{}
	if err := utils.UnmarshalJSON(data, &accountWiselyCard, "", true, true); err == nil {
		u.AccountWiselyCard = &accountWiselyCard
		u.Type = DetailsInputTypeAccountWiselyCard
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DetailsInput", string(data))
}

func (u DetailsInput) MarshalJSON() ([]byte, error) {
	if u.AccountDebitCardInput != nil {
		return utils.MarshalJSON(u.AccountDebitCardInput, "", true)
	}

	if u.AccountGalileoCardInput != nil {
		return utils.MarshalJSON(u.AccountGalileoCardInput, "", true)
	}

	if u.AccountWiselyCard != nil {
		return utils.MarshalJSON(u.AccountWiselyCard, "", true)
	}

	return nil, errors.New("could not marshal union type DetailsInput: all fields are null")
}

// CardInput - An account with type `CARD` and subtype `GALILEO`, `WISELY`, or `DEBIT`.
type CardInput struct {
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"CARD" json:"account_type"`
	// The subtype of the account.
	Subtype AccountAttributesCardSubtype `json:"subtype"`
	// The banking details of the account and account holder.
	Details DetailsInput `json:"details"`
}

func (c CardInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CardInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *CardInput) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CardInput) GetAccountType() string {
	return "CARD"
}

func (o *CardInput) GetSubtype() AccountAttributesCardSubtype {
	if o == nil {
		return AccountAttributesCardSubtype("")
	}
	return o.Subtype
}

func (o *CardInput) GetDetails() DetailsInput {
	if o == nil {
		return DetailsInput{}
	}
	return o.Details
}

type AccountAttributesInputType string

const (
	AccountAttributesInputTypeCardInput                    AccountAttributesInputType = "Card_input"
	AccountAttributesInputTypeEarningsBalanceReadOnlyInput AccountAttributesInputType = "Earnings Balance (read only)_input"
	AccountAttributesInputTypeDepositoryInput              AccountAttributesInputType = "Depository_input"
)

// AccountAttributesInput - The details of the account.
type AccountAttributesInput struct {
	CardInput                    *CardInput                    `queryParam:"inline"`
	EarningsBalanceReadOnlyInput *EarningsBalanceReadOnlyInput `queryParam:"inline"`
	DepositoryInput              *DepositoryInput              `queryParam:"inline"`

	Type AccountAttributesInputType
}

func CreateAccountAttributesInputCardInput(cardInput CardInput) AccountAttributesInput {
	typ := AccountAttributesInputTypeCardInput

	return AccountAttributesInput{
		CardInput: &cardInput,
		Type:      typ,
	}
}

func CreateAccountAttributesInputEarningsBalanceReadOnlyInput(earningsBalanceReadOnlyInput EarningsBalanceReadOnlyInput) AccountAttributesInput {
	typ := AccountAttributesInputTypeEarningsBalanceReadOnlyInput

	return AccountAttributesInput{
		EarningsBalanceReadOnlyInput: &earningsBalanceReadOnlyInput,
		Type:                         typ,
	}
}

func CreateAccountAttributesInputDepositoryInput(depositoryInput DepositoryInput) AccountAttributesInput {
	typ := AccountAttributesInputTypeDepositoryInput

	return AccountAttributesInput{
		DepositoryInput: &depositoryInput,
		Type:            typ,
	}
}

func (u *AccountAttributesInput) UnmarshalJSON(data []byte) error {

	var earningsBalanceReadOnlyInput EarningsBalanceReadOnlyInput = EarningsBalanceReadOnlyInput{}
	if err := utils.UnmarshalJSON(data, &earningsBalanceReadOnlyInput, "", true, true); err == nil {
		u.EarningsBalanceReadOnlyInput = &earningsBalanceReadOnlyInput
		u.Type = AccountAttributesInputTypeEarningsBalanceReadOnlyInput
		return nil
	}

	var cardInput CardInput = CardInput{}
	if err := utils.UnmarshalJSON(data, &cardInput, "", true, true); err == nil {
		u.CardInput = &cardInput
		u.Type = AccountAttributesInputTypeCardInput
		return nil
	}

	var depositoryInput DepositoryInput = DepositoryInput{}
	if err := utils.UnmarshalJSON(data, &depositoryInput, "", true, true); err == nil {
		u.DepositoryInput = &depositoryInput
		u.Type = AccountAttributesInputTypeDepositoryInput
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccountAttributesInput", string(data))
}

func (u AccountAttributesInput) MarshalJSON() ([]byte, error) {
	if u.CardInput != nil {
		return utils.MarshalJSON(u.CardInput, "", true)
	}

	if u.EarningsBalanceReadOnlyInput != nil {
		return utils.MarshalJSON(u.EarningsBalanceReadOnlyInput, "", true)
	}

	if u.DepositoryInput != nil {
		return utils.MarshalJSON(u.DepositoryInput, "", true)
	}

	return nil, errors.New("could not marshal union type AccountAttributesInput: all fields are null")
}
