// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

// AccountAttributesDepositoryVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesDepositoryVerificationStatus string

const (
	AccountAttributesDepositoryVerificationStatusVerificationPending AccountAttributesDepositoryVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesDepositoryVerificationStatusVerificationFailed  AccountAttributesDepositoryVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesDepositoryVerificationStatusVerified            AccountAttributesDepositoryVerificationStatus = "VERIFIED"
)

func (e AccountAttributesDepositoryVerificationStatus) ToPointer() *AccountAttributesDepositoryVerificationStatus {
	return &e
}
func (e *AccountAttributesDepositoryVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesDepositoryVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesDepositoryVerificationStatus: %v", v)
	}
}

type AccountAttributesDepositoryAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	// This value is in units of the lowest denomination in the associated currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to $72.50.
	// **Special note for Earnings Balance accounts:**
	// If a user transfers money from an Earnings Balance account to a personal account, the `current` balance may be negative as those transfers settle. When a paycheck is processed, DailyPay will automatically attempt to zero out the balance,  transferring any remaining funds to the `direct_deposit_default_depository` account set for the associated Job.
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,  which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (a AccountAttributesDepositoryAccountBalances) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesDepositoryAccountBalances) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"available", "current", "currency"}); err != nil {
		return err
	}
	return nil
}

func (o *AccountAttributesDepositoryAccountBalances) GetAvailable() *int64 {
	if o == nil {
		return nil
	}
	return o.Available
}

func (o *AccountAttributesDepositoryAccountBalances) GetCurrent() *int64 {
	if o == nil {
		return nil
	}
	return o.Current
}

func (o *AccountAttributesDepositoryAccountBalances) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

type AccountAttributesDepositoryAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (a AccountAttributesDepositoryAccountCapabilities) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesDepositoryAccountCapabilities) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"transfer_destination"}); err != nil {
		return err
	}
	return nil
}

func (o *AccountAttributesDepositoryAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if o == nil {
		return []TransferDestinationCapability{}
	}
	return o.TransferDestination
}

// AccountAttributesDepositorySubtype - The subtype of the account.
type AccountAttributesDepositorySubtype string

const (
	AccountAttributesDepositorySubtypeSavings  AccountAttributesDepositorySubtype = "SAVINGS"
	AccountAttributesDepositorySubtypeChecking AccountAttributesDepositorySubtype = "CHECKING"
)

func (e AccountAttributesDepositorySubtype) ToPointer() *AccountAttributesDepositorySubtype {
	return &e
}
func (e *AccountAttributesDepositorySubtype) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SAVINGS":
		fallthrough
	case "CHECKING":
		*e = AccountAttributesDepositorySubtype(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesDepositorySubtype: %v", v)
	}
}

// DepositoryAccountDetails - The banking details of the account and account holder.
type DepositoryAccountDetails struct {
	// The first name of the account holder.
	FirstName string `json:"first_name"`
	// The last name of the account holder.
	LastName string `json:"last_name"`
	// The routing number of the bank that holds this account. Responses from this API that return this number are masked to the last four digits.
	RoutingNumber string `json:"routing_number"`
	// The account number. Responses from this API that return this number are masked to the last four digits.
	AccountNumber string `json:"account_number"`
}

func (d DepositoryAccountDetails) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DepositoryAccountDetails) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"first_name", "last_name", "routing_number", "account_number"}); err != nil {
		return err
	}
	return nil
}

func (o *DepositoryAccountDetails) GetFirstName() string {
	if o == nil {
		return ""
	}
	return o.FirstName
}

func (o *DepositoryAccountDetails) GetLastName() string {
	if o == nil {
		return ""
	}
	return o.LastName
}

func (o *DepositoryAccountDetails) GetRoutingNumber() string {
	if o == nil {
		return ""
	}
	return o.RoutingNumber
}

func (o *DepositoryAccountDetails) GetAccountNumber() string {
	if o == nil {
		return ""
	}
	return o.AccountNumber
}

// Depository - An account with type `DEPOSITORY` and subtype `SAVINGS` or `CHECKING`.
type Depository struct {
	// A code that indicates the status of an account that is a destination for funds.
	VerificationStatus  AccountAttributesDepositoryVerificationStatus  `json:"verification_status"`
	AccountBalances     AccountAttributesDepositoryAccountBalances     `json:"balances"`
	AccountCapabilities AccountAttributesDepositoryAccountCapabilities `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"DEPOSITORY" json:"account_type"`
	// The subtype of the account.
	Subtype AccountAttributesDepositorySubtype `json:"subtype"`
	// The banking details of the account and account holder.
	DepositoryAccountDetails DepositoryAccountDetails `json:"details"`
}

func (d Depository) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Depository) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"verification_status", "balances", "capabilities", "name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *Depository) GetVerificationStatus() AccountAttributesDepositoryVerificationStatus {
	if o == nil {
		return AccountAttributesDepositoryVerificationStatus("")
	}
	return o.VerificationStatus
}

func (o *Depository) GetAccountBalances() AccountAttributesDepositoryAccountBalances {
	if o == nil {
		return AccountAttributesDepositoryAccountBalances{}
	}
	return o.AccountBalances
}

func (o *Depository) GetAccountCapabilities() AccountAttributesDepositoryAccountCapabilities {
	if o == nil {
		return AccountAttributesDepositoryAccountCapabilities{}
	}
	return o.AccountCapabilities
}

func (o *Depository) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Depository) GetAccountType() string {
	return "DEPOSITORY"
}

func (o *Depository) GetSubtype() AccountAttributesDepositorySubtype {
	if o == nil {
		return AccountAttributesDepositorySubtype("")
	}
	return o.Subtype
}

func (o *Depository) GetDepositoryAccountDetails() DepositoryAccountDetails {
	if o == nil {
		return DepositoryAccountDetails{}
	}
	return o.DepositoryAccountDetails
}

// AccountAttributesEarningsBalanceVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesEarningsBalanceVerificationStatus string

const (
	AccountAttributesEarningsBalanceVerificationStatusVerificationPending AccountAttributesEarningsBalanceVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesEarningsBalanceVerificationStatusVerificationFailed  AccountAttributesEarningsBalanceVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesEarningsBalanceVerificationStatusVerified            AccountAttributesEarningsBalanceVerificationStatus = "VERIFIED"
)

func (e AccountAttributesEarningsBalanceVerificationStatus) ToPointer() *AccountAttributesEarningsBalanceVerificationStatus {
	return &e
}
func (e *AccountAttributesEarningsBalanceVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesEarningsBalanceVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesEarningsBalanceVerificationStatus: %v", v)
	}
}

type AccountAttributesEarningsBalanceAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	// This value is in units of the lowest denomination in the associated currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to $72.50.
	// **Special note for Earnings Balance accounts:**
	// If a user transfers money from an Earnings Balance account to a personal account, the `current` balance may be negative as those transfers settle. When a paycheck is processed, DailyPay will automatically attempt to zero out the balance,  transferring any remaining funds to the `direct_deposit_default_depository` account set for the associated Job.
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,  which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (a AccountAttributesEarningsBalanceAccountBalances) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesEarningsBalanceAccountBalances) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"available", "current", "currency"}); err != nil {
		return err
	}
	return nil
}

func (o *AccountAttributesEarningsBalanceAccountBalances) GetAvailable() *int64 {
	if o == nil {
		return nil
	}
	return o.Available
}

func (o *AccountAttributesEarningsBalanceAccountBalances) GetCurrent() *int64 {
	if o == nil {
		return nil
	}
	return o.Current
}

func (o *AccountAttributesEarningsBalanceAccountBalances) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

type AccountAttributesEarningsBalanceAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (a AccountAttributesEarningsBalanceAccountCapabilities) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesEarningsBalanceAccountCapabilities) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"transfer_destination"}); err != nil {
		return err
	}
	return nil
}

func (o *AccountAttributesEarningsBalanceAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if o == nil {
		return []TransferDestinationCapability{}
	}
	return o.TransferDestination
}

// Details - An empty object for earnings balance accounts.
type Details struct {
}

func (d Details) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Details) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

// EarningsBalanceReadOnly - An account with type `EARNINGS_BALANCE` and subtype `ODP`.
type EarningsBalanceReadOnly struct {
	// A code that indicates the status of an account that is a destination for funds.
	VerificationStatus  AccountAttributesEarningsBalanceVerificationStatus  `json:"verification_status"`
	AccountBalances     AccountAttributesEarningsBalanceAccountBalances     `json:"balances"`
	AccountCapabilities AccountAttributesEarningsBalanceAccountCapabilities `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"EARNINGS_BALANCE" json:"account_type"`
	// The subtype of the account.
	subtype string `const:"ODP" json:"subtype"`
	// An empty object for earnings balance accounts.
	Details Details `json:"details"`
}

func (e EarningsBalanceReadOnly) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EarningsBalanceReadOnly) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"verification_status", "balances", "capabilities", "name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *EarningsBalanceReadOnly) GetVerificationStatus() AccountAttributesEarningsBalanceVerificationStatus {
	if o == nil {
		return AccountAttributesEarningsBalanceVerificationStatus("")
	}
	return o.VerificationStatus
}

func (o *EarningsBalanceReadOnly) GetAccountBalances() AccountAttributesEarningsBalanceAccountBalances {
	if o == nil {
		return AccountAttributesEarningsBalanceAccountBalances{}
	}
	return o.AccountBalances
}

func (o *EarningsBalanceReadOnly) GetAccountCapabilities() AccountAttributesEarningsBalanceAccountCapabilities {
	if o == nil {
		return AccountAttributesEarningsBalanceAccountCapabilities{}
	}
	return o.AccountCapabilities
}

func (o *EarningsBalanceReadOnly) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *EarningsBalanceReadOnly) GetAccountType() string {
	return "EARNINGS_BALANCE"
}

func (o *EarningsBalanceReadOnly) GetSubtype() string {
	return "ODP"
}

func (o *EarningsBalanceReadOnly) GetDetails() Details {
	if o == nil {
		return Details{}
	}
	return o.Details
}

// AccountAttributesCardVerificationStatus - A code that indicates the status of an account that is a destination for funds.
type AccountAttributesCardVerificationStatus string

const (
	AccountAttributesCardVerificationStatusVerificationPending AccountAttributesCardVerificationStatus = "VERIFICATION_PENDING"
	AccountAttributesCardVerificationStatusVerificationFailed  AccountAttributesCardVerificationStatus = "VERIFICATION_FAILED"
	AccountAttributesCardVerificationStatusVerified            AccountAttributesCardVerificationStatus = "VERIFIED"
)

func (e AccountAttributesCardVerificationStatus) ToPointer() *AccountAttributesCardVerificationStatus {
	return &e
}
func (e *AccountAttributesCardVerificationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "VERIFICATION_PENDING":
		fallthrough
	case "VERIFICATION_FAILED":
		fallthrough
	case "VERIFIED":
		*e = AccountAttributesCardVerificationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesCardVerificationStatus: %v", v)
	}
}

type AccountAttributesCardAccountBalances struct {
	// The amount of funds available to be withdrawn from the account.
	//
	// For earnings_balance-type accounts, the available balance typically
	// equals the current balance less any pending outflows, plus any pending inflows,
	//
	//
	// This value is in units of the lowest denomination in the associated
	// currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to
	// $72.50.
	//
	Available *int64 `json:"available"`
	// The total amount of funds settled in the account.
	// This value is in units of the lowest denomination in the associated currency. For example, `{ amount: 7250, currency: 'USD' }` resolves to $72.50.
	// **Special note for Earnings Balance accounts:**
	// If a user transfers money from an Earnings Balance account to a personal account, the `current` balance may be negative as those transfers settle. When a paycheck is processed, DailyPay will automatically attempt to zero out the balance,  transferring any remaining funds to the `direct_deposit_default_depository` account set for the associated Job.
	// If DailyPay is unable to zero out the balance during paycheck processing, the `current` balance will remain negative,  which may impact a user's ability to transfer additional funds from their earnings balance.
	// In those cases, the available balance will be 0.
	//
	Current *int64 `json:"current"`
	// A three-letter ISO 4217 currency code. For example, `USD` for US Dollars, `EUR` for Euros, or `JPY` for Japanese Yen.
	Currency string `json:"currency"`
}

func (a AccountAttributesCardAccountBalances) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesCardAccountBalances) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"available", "current", "currency"}); err != nil {
		return err
	}
	return nil
}

func (o *AccountAttributesCardAccountBalances) GetAvailable() *int64 {
	if o == nil {
		return nil
	}
	return o.Available
}

func (o *AccountAttributesCardAccountBalances) GetCurrent() *int64 {
	if o == nil {
		return nil
	}
	return o.Current
}

func (o *AccountAttributesCardAccountBalances) GetCurrency() string {
	if o == nil {
		return ""
	}
	return o.Currency
}

type AccountAttributesCardAccountCapabilities struct {
	// List of the timing and associate fees available when crediting this account as a
	// transfer destination.
	//
	// Actual fees may differ at the time of transfer; please refer to
	// the transfer preview attribute for the most accurate fee information
	// for any given transfer.
	//
	TransferDestination []TransferDestinationCapability `json:"transfer_destination"`
}

func (a AccountAttributesCardAccountCapabilities) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccountAttributesCardAccountCapabilities) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"transfer_destination"}); err != nil {
		return err
	}
	return nil
}

func (o *AccountAttributesCardAccountCapabilities) GetTransferDestination() []TransferDestinationCapability {
	if o == nil {
		return []TransferDestinationCapability{}
	}
	return o.TransferDestination
}

// AccountAttributesCardSubtype - The subtype of the account. Additional subtypes may be added over time
type AccountAttributesCardSubtype string

const (
	AccountAttributesCardSubtypeDebit    AccountAttributesCardSubtype = "DEBIT"
	AccountAttributesCardSubtypeDailypay AccountAttributesCardSubtype = "DAILYPAY"
)

func (e AccountAttributesCardSubtype) ToPointer() *AccountAttributesCardSubtype {
	return &e
}
func (e *AccountAttributesCardSubtype) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DEBIT":
		fallthrough
	case "DAILYPAY":
		*e = AccountAttributesCardSubtype(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AccountAttributesCardSubtype: %v", v)
	}
}

// CardAccountDetailsOutput - The banking details of the account and account holder.
type CardAccountDetailsOutput struct {
	// Last four digits of the card number.
	LastFour string `json:"last_four"`
	// The issuer of the card.
	Issuer string `json:"issuer"`
	// The first name of the account holder.
	FirstName string `json:"first_name"`
	// The last name of the account holder.
	LastName string `json:"last_name"`
	// The month of the expiration date for the card.
	ExpirationMonth string `json:"expiration_month"`
	// The year of the expiration date for the card.
	ExpirationYear string `json:"expiration_year"`
}

func (c CardAccountDetailsOutput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CardAccountDetailsOutput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"last_four", "issuer", "first_name", "last_name", "expiration_month", "expiration_year"}); err != nil {
		return err
	}
	return nil
}

func (o *CardAccountDetailsOutput) GetLastFour() string {
	if o == nil {
		return ""
	}
	return o.LastFour
}

func (o *CardAccountDetailsOutput) GetIssuer() string {
	if o == nil {
		return ""
	}
	return o.Issuer
}

func (o *CardAccountDetailsOutput) GetFirstName() string {
	if o == nil {
		return ""
	}
	return o.FirstName
}

func (o *CardAccountDetailsOutput) GetLastName() string {
	if o == nil {
		return ""
	}
	return o.LastName
}

func (o *CardAccountDetailsOutput) GetExpirationMonth() string {
	if o == nil {
		return ""
	}
	return o.ExpirationMonth
}

func (o *CardAccountDetailsOutput) GetExpirationYear() string {
	if o == nil {
		return ""
	}
	return o.ExpirationYear
}

// CardOutput - An account with type `CARD` and subtype `DAILYPAY` or `DEBIT`.
type CardOutput struct {
	// A code that indicates the status of an account that is a destination for funds.
	VerificationStatus  AccountAttributesCardVerificationStatus  `json:"verification_status"`
	AccountBalances     AccountAttributesCardAccountBalances     `json:"balances"`
	AccountCapabilities AccountAttributesCardAccountCapabilities `json:"capabilities"`
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"CARD" json:"account_type"`
	// The subtype of the account. Additional subtypes may be added over time
	Subtype AccountAttributesCardSubtype `json:"subtype"`
	// The banking details of the account and account holder.
	CardAccountDetails CardAccountDetailsOutput `json:"details"`
}

func (c CardOutput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CardOutput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"verification_status", "balances", "capabilities", "name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *CardOutput) GetVerificationStatus() AccountAttributesCardVerificationStatus {
	if o == nil {
		return AccountAttributesCardVerificationStatus("")
	}
	return o.VerificationStatus
}

func (o *CardOutput) GetAccountBalances() AccountAttributesCardAccountBalances {
	if o == nil {
		return AccountAttributesCardAccountBalances{}
	}
	return o.AccountBalances
}

func (o *CardOutput) GetAccountCapabilities() AccountAttributesCardAccountCapabilities {
	if o == nil {
		return AccountAttributesCardAccountCapabilities{}
	}
	return o.AccountCapabilities
}

func (o *CardOutput) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CardOutput) GetAccountType() string {
	return "CARD"
}

func (o *CardOutput) GetSubtype() AccountAttributesCardSubtype {
	if o == nil {
		return AccountAttributesCardSubtype("")
	}
	return o.Subtype
}

func (o *CardOutput) GetCardAccountDetails() CardAccountDetailsOutput {
	if o == nil {
		return CardAccountDetailsOutput{}
	}
	return o.CardAccountDetails
}

type AccountAttributesOutputType string

const (
	AccountAttributesOutputTypeCard            AccountAttributesOutputType = "CARD"
	AccountAttributesOutputTypeEarningsBalance AccountAttributesOutputType = "EARNINGS_BALANCE"
	AccountAttributesOutputTypeDepository      AccountAttributesOutputType = "DEPOSITORY"
)

// AccountAttributesOutput - The details of the account.
type AccountAttributesOutput struct {
	CardOutput              *CardOutput              `queryParam:"inline"`
	EarningsBalanceReadOnly *EarningsBalanceReadOnly `queryParam:"inline"`
	Depository              *Depository              `queryParam:"inline"`

	Type AccountAttributesOutputType
}

func CreateAccountAttributesOutputCard(card CardOutput) AccountAttributesOutput {
	typ := AccountAttributesOutputTypeCard

	return AccountAttributesOutput{
		CardOutput: &card,
		Type:       typ,
	}
}

func CreateAccountAttributesOutputEarningsBalance(earningsBalance EarningsBalanceReadOnly) AccountAttributesOutput {
	typ := AccountAttributesOutputTypeEarningsBalance

	return AccountAttributesOutput{
		EarningsBalanceReadOnly: &earningsBalance,
		Type:                    typ,
	}
}

func CreateAccountAttributesOutputDepository(depository Depository) AccountAttributesOutput {
	typ := AccountAttributesOutputTypeDepository

	return AccountAttributesOutput{
		Depository: &depository,
		Type:       typ,
	}
}

func (u *AccountAttributesOutput) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		AccountType string `json:"account_type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.AccountType {
	case "CARD":
		cardOutput := new(CardOutput)
		if err := utils.UnmarshalJSON(data, &cardOutput, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (AccountType == CARD) type CardOutput within AccountAttributesOutput: %w", string(data), err)
		}

		u.CardOutput = cardOutput
		u.Type = AccountAttributesOutputTypeCard
		return nil
	case "EARNINGS_BALANCE":
		earningsBalanceReadOnly := new(EarningsBalanceReadOnly)
		if err := utils.UnmarshalJSON(data, &earningsBalanceReadOnly, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (AccountType == EARNINGS_BALANCE) type EarningsBalanceReadOnly within AccountAttributesOutput: %w", string(data), err)
		}

		u.EarningsBalanceReadOnly = earningsBalanceReadOnly
		u.Type = AccountAttributesOutputTypeEarningsBalance
		return nil
	case "DEPOSITORY":
		depository := new(Depository)
		if err := utils.UnmarshalJSON(data, &depository, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (AccountType == DEPOSITORY) type Depository within AccountAttributesOutput: %w", string(data), err)
		}

		u.Depository = depository
		u.Type = AccountAttributesOutputTypeDepository
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccountAttributesOutput", string(data))
}

func (u AccountAttributesOutput) MarshalJSON() ([]byte, error) {
	if u.CardOutput != nil {
		return utils.MarshalJSON(u.CardOutput, "", true)
	}

	if u.EarningsBalanceReadOnly != nil {
		return utils.MarshalJSON(u.EarningsBalanceReadOnly, "", true)
	}

	if u.Depository != nil {
		return utils.MarshalJSON(u.Depository, "", true)
	}

	return nil, errors.New("could not marshal union type AccountAttributesOutput: all fields are null")
}

// DepositoryInput - An account with type `DEPOSITORY` and subtype `SAVINGS` or `CHECKING`.
type DepositoryInput struct {
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"DEPOSITORY" json:"account_type"`
	// The subtype of the account.
	Subtype AccountAttributesDepositorySubtype `json:"subtype"`
	// The banking details of the account and account holder.
	DepositoryAccountDetails DepositoryAccountDetails `json:"details"`
}

func (d DepositoryInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DepositoryInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *DepositoryInput) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *DepositoryInput) GetAccountType() string {
	return "DEPOSITORY"
}

func (o *DepositoryInput) GetSubtype() AccountAttributesDepositorySubtype {
	if o == nil {
		return AccountAttributesDepositorySubtype("")
	}
	return o.Subtype
}

func (o *DepositoryInput) GetDepositoryAccountDetails() DepositoryAccountDetails {
	if o == nil {
		return DepositoryAccountDetails{}
	}
	return o.DepositoryAccountDetails
}

// EarningsBalanceReadOnlyInput - An account with type `EARNINGS_BALANCE` and subtype `ODP`.
type EarningsBalanceReadOnlyInput struct {
}

func (e EarningsBalanceReadOnlyInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EarningsBalanceReadOnlyInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

// CardAccountDetailsInput - The banking details of the account and account holder.
type CardAccountDetailsInput struct {
	// A tokenized string replacement for the card data.
	Token string `json:"token"`
	// The first name of the account holder.
	FirstName string `json:"first_name"`
	// The last name of the account holder.
	LastName string `json:"last_name"`
	// The month of the expiration date for the card.
	ExpirationMonth string `json:"expiration_month"`
	// The year of the expiration date for the card.
	ExpirationYear string `json:"expiration_year"`
	// The first line of the address for the card.
	AddressLineOne string `json:"address_line_one"`
	// The second line of the address for the card.
	AddressLineTwo *string `json:"address_line_two,omitempty"`
	// The city of the address for the card.
	AddressCity string `json:"address_city"`
	// The two-letter abbreviation of the state in the address for the card.
	AddressState string `json:"address_state"`
	// The zip code of the address for the card.
	AddressZipCode string `json:"address_zip_code"`
	// The country code of the address for the card.
	AddressCountry string `json:"address_country"`
}

func (c CardAccountDetailsInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CardAccountDetailsInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"token", "first_name", "last_name", "expiration_month", "expiration_year", "address_line_one", "address_city", "address_state", "address_zip_code", "address_country"}); err != nil {
		return err
	}
	return nil
}

func (o *CardAccountDetailsInput) GetToken() string {
	if o == nil {
		return ""
	}
	return o.Token
}

func (o *CardAccountDetailsInput) GetFirstName() string {
	if o == nil {
		return ""
	}
	return o.FirstName
}

func (o *CardAccountDetailsInput) GetLastName() string {
	if o == nil {
		return ""
	}
	return o.LastName
}

func (o *CardAccountDetailsInput) GetExpirationMonth() string {
	if o == nil {
		return ""
	}
	return o.ExpirationMonth
}

func (o *CardAccountDetailsInput) GetExpirationYear() string {
	if o == nil {
		return ""
	}
	return o.ExpirationYear
}

func (o *CardAccountDetailsInput) GetAddressLineOne() string {
	if o == nil {
		return ""
	}
	return o.AddressLineOne
}

func (o *CardAccountDetailsInput) GetAddressLineTwo() *string {
	if o == nil {
		return nil
	}
	return o.AddressLineTwo
}

func (o *CardAccountDetailsInput) GetAddressCity() string {
	if o == nil {
		return ""
	}
	return o.AddressCity
}

func (o *CardAccountDetailsInput) GetAddressState() string {
	if o == nil {
		return ""
	}
	return o.AddressState
}

func (o *CardAccountDetailsInput) GetAddressZipCode() string {
	if o == nil {
		return ""
	}
	return o.AddressZipCode
}

func (o *CardAccountDetailsInput) GetAddressCountry() string {
	if o == nil {
		return ""
	}
	return o.AddressCountry
}

// CardInput - An account with type `CARD` and subtype `DAILYPAY` or `DEBIT`.
type CardInput struct {
	// Display name for this account.
	Name string `json:"name"`
	// The type of account. It differentiates between depository accounts (e.g. bank account), cards (e.g. debit) and earnings balance type of accounts (e.g. on demand pay).
	accountType string `const:"CARD" json:"account_type"`
	// The subtype of the account. Additional subtypes may be added over time
	Subtype AccountAttributesCardSubtype `json:"subtype"`
	// The banking details of the account and account holder.
	CardAccountDetails CardAccountDetailsInput `json:"details"`
}

func (c CardInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CardInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"name", "account_type", "subtype", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *CardInput) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CardInput) GetAccountType() string {
	return "CARD"
}

func (o *CardInput) GetSubtype() AccountAttributesCardSubtype {
	if o == nil {
		return AccountAttributesCardSubtype("")
	}
	return o.Subtype
}

func (o *CardInput) GetCardAccountDetails() CardAccountDetailsInput {
	if o == nil {
		return CardAccountDetailsInput{}
	}
	return o.CardAccountDetails
}

type AccountAttributesInputType string

const (
	AccountAttributesInputTypeCardInput                    AccountAttributesInputType = "Card_input"
	AccountAttributesInputTypeEarningsBalanceReadOnlyInput AccountAttributesInputType = "Earnings Balance (read only)_input"
	AccountAttributesInputTypeDepositoryInput              AccountAttributesInputType = "Depository_input"
)

// AccountAttributesInput - The details of the account.
type AccountAttributesInput struct {
	CardInput                    *CardInput                    `queryParam:"inline"`
	EarningsBalanceReadOnlyInput *EarningsBalanceReadOnlyInput `queryParam:"inline"`
	DepositoryInput              *DepositoryInput              `queryParam:"inline"`

	Type AccountAttributesInputType
}

func CreateAccountAttributesInputCardInput(cardInput CardInput) AccountAttributesInput {
	typ := AccountAttributesInputTypeCardInput

	return AccountAttributesInput{
		CardInput: &cardInput,
		Type:      typ,
	}
}

func CreateAccountAttributesInputEarningsBalanceReadOnlyInput(earningsBalanceReadOnlyInput EarningsBalanceReadOnlyInput) AccountAttributesInput {
	typ := AccountAttributesInputTypeEarningsBalanceReadOnlyInput

	return AccountAttributesInput{
		EarningsBalanceReadOnlyInput: &earningsBalanceReadOnlyInput,
		Type:                         typ,
	}
}

func CreateAccountAttributesInputDepositoryInput(depositoryInput DepositoryInput) AccountAttributesInput {
	typ := AccountAttributesInputTypeDepositoryInput

	return AccountAttributesInput{
		DepositoryInput: &depositoryInput,
		Type:            typ,
	}
}

func (u *AccountAttributesInput) UnmarshalJSON(data []byte) error {

	var cardInput CardInput = CardInput{}
	if err := utils.UnmarshalJSON(data, &cardInput, "", true, nil); err == nil {
		u.CardInput = &cardInput
		u.Type = AccountAttributesInputTypeCardInput
		return nil
	}

	var depositoryInput DepositoryInput = DepositoryInput{}
	if err := utils.UnmarshalJSON(data, &depositoryInput, "", true, nil); err == nil {
		u.DepositoryInput = &depositoryInput
		u.Type = AccountAttributesInputTypeDepositoryInput
		return nil
	}

	var earningsBalanceReadOnlyInput EarningsBalanceReadOnlyInput = EarningsBalanceReadOnlyInput{}
	if err := utils.UnmarshalJSON(data, &earningsBalanceReadOnlyInput, "", true, nil); err == nil {
		u.EarningsBalanceReadOnlyInput = &earningsBalanceReadOnlyInput
		u.Type = AccountAttributesInputTypeEarningsBalanceReadOnlyInput
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccountAttributesInput", string(data))
}

func (u AccountAttributesInput) MarshalJSON() ([]byte, error) {
	if u.CardInput != nil {
		return utils.MarshalJSON(u.CardInput, "", true)
	}

	if u.EarningsBalanceReadOnlyInput != nil {
		return utils.MarshalJSON(u.EarningsBalanceReadOnlyInput, "", true)
	}

	if u.DepositoryInput != nil {
		return utils.MarshalJSON(u.DepositoryInput, "", true)
	}

	return nil, errors.New("could not marshal union type AccountAttributesInput: all fields are null")
}
