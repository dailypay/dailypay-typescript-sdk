/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { stringToBase64 } from "../lib/base64.js";
import { SDKOptions } from "../lib/config.js";
import { HTTPClient } from "../lib/http.js";
import { OAuth2Session, OAuth2SessionStore } from "../lib/oauth2-sessions.js";
import { parse } from "../lib/schemas.js";
import * as models from "../models/index.js";
import {
  AfterErrorContext,
  AfterErrorHook,
  BeforeRequestContext,
  BeforeRequestHook,
  HookContext,
  SDKInitHook,
} from "./types.js";

type Credentials = {
  clientID: string;
  clientSecret: string;
  tokenURL: string | undefined;
  scopes: string[] | undefined;
  additionalProperties: Record<string, string>;
};

const TokenResponseDataSchema = z.object({
  access_token: z.string(),
  token_type: z.string(),
  expires_in: z.number().optional(),
});

export class ClientCredentialsHook
  implements SDKInitHook, BeforeRequestHook, AfterErrorHook
{
  private client?: HTTPClient;
  private sessionStore = new OAuth2SessionStore();

  sdkInit(opts: SDKOptions): SDKOptions {
    this.client = opts.httpClient || new HTTPClient();

    return opts;
  }

  private isHookDisabled(hookCtx: HookContext): boolean {
    return !hookCtx.oAuth2Scopes;
  }

  async beforeRequest(
    hookCtx: BeforeRequestContext,
    request: Request,
  ): Promise<Request> {
    if (this.isHookDisabled(hookCtx)) {
      return request;
    }

    const credentials = await this.getCredentials(hookCtx);
    if (!credentials || Object.values(credentials).some(v => v === "")) {
      return request;
    }

    const sessionKey = this.getSessionKey(credentials);
    const requiredScopes = this.getRequiredScopes(
      credentials,
      hookCtx.oAuth2Scopes!,
    );

    let session = this.sessionStore.getSession(sessionKey, requiredScopes);

    if (!session) {
      session = await this.doTokenRequest(
        hookCtx,
        credentials,
        requiredScopes,
      );

      this.sessionStore.storeSession(sessionKey, requiredScopes, session);
    }

    request.headers.set("Authorization", `Bearer ${session.token}`);

    return request;
  }

  async afterError(
    hookCtx: AfterErrorContext,
    response: Response | null,
    error: unknown,
  ): Promise<{ response: Response | null; error: unknown }> {
    if (!hookCtx.oAuth2Scopes) {
      // OAuth2 not in use
      return { response, error };
    }

    if (error) {
      return { response, error };
    }

    const credentials = await this.getCredentials(hookCtx);
    if (!credentials || Object.values(credentials).some(v => v === "")) {
      return { response, error };
    }

    if (response && response?.status === 401) {
      const sessionKey = this.getSessionKey(credentials);
      const requiredScopes = this.getRequiredScopes(
        credentials,
        hookCtx.oAuth2Scopes!,
      );
      this.sessionStore.deleteSession(sessionKey, requiredScopes);
    }

    return { response, error };
  }

  private async doTokenRequest(
    hookCtx: HookContext,
    credentials: Credentials,
    scopes: string[],
  ): Promise<OAuth2Session> {
    const formData = new URLSearchParams();
    formData.append("grant_type", "client_credentials");

    const headers: Record<string, string> = {
      "Content-Type": "application/x-www-form-urlencoded",
    };

    formData.append("client_id", credentials.clientID);
    formData.append("client_secret", credentials.clientSecret);

    if (scopes.length > 0) {
      formData.append("scope", scopes.join(" "));
    }

    for (
      const [key, value] of Object.entries(credentials.additionalProperties)
    ) {
      formData.append(key, value);
    }

    if (!hookCtx.baseURL?.toString()) {
      throw new Error("Assertion error: Base URL cannot be empty");
    }
    const tokenURL = new URL(credentials.tokenURL ?? "", hookCtx.baseURL);

    const request = new Request(tokenURL, {
      method: "POST",
      headers,
      body: formData,
    });

    const res = await this.client?.request(request);
    if (!res) {
      throw new Error("Failed to fetch token");
    }

    if (res.status < 200 || res.status >= 300) {
      let errorMessage =
        `Received unexpected status code ${res.status} while fetching token`;
      try {
        errorMessage += `: ${await res.text()}`;
      } catch {
        // ignore response body
      }
      throw new Error(errorMessage);
    }

    const rawData = await res.json();
    const tokenResponseData = parse(
      rawData,
      (val) => TokenResponseDataSchema.parse(val),
      "Invalid token response format",
    );

    const session: OAuth2Session = {
      token: tokenResponseData.access_token,
      scopes,
    };

    if (tokenResponseData.expires_in !== undefined) {
      session.expiresAt = Date.now() + tokenResponseData.expires_in * 1000;
    }

    return session;
  }

  private async getCredentials(
    hookCtx: HookContext,
  ): Promise<Credentials | null> {
    const source = hookCtx.securitySource;

    if (!source) {
      return null;
    }

    let security = source;
    if (typeof source === "function") {
      security = await source();
    }

    return this.getCredentialsGlobal(security);
  }

  private async getCredentialsGlobal(
    security: unknown,
  ): Promise<Credentials | null> {
    const out = parse(
      security,
      (val) => models.Security$outboundSchema.parse(val),
      "unexpected security type",
    );

    const additionalProperties: Record<string, string> = {};
    for (
      const [key, value] of Object.entries(
        out?.oauth_client_credentials_token ?? {},
      )
    ) {
      if (
        typeof value === "string"
        && !["clientID", "clientSecret", "tokenURL", "scopes"].includes(key)
      ) {
        additionalProperties[key] = value;
      }
    }

    return {
      clientID: out?.oauth_client_credentials_token?.clientID ?? "",
      clientSecret: out?.oauth_client_credentials_token?.clientSecret ?? "",
      tokenURL: out?.oauth_client_credentials_token?.tokenURL ?? "",
      scopes: undefined,
      additionalProperties,
    };
  }

  private getSessionKey(credentials: Credentials): string {
    const key = `${credentials.clientID}:${credentials.clientSecret}`;
    return stringToBase64(key);
  }

  private getRequiredScopes(
    credentials: Credentials,
    oAuth2Scopes: string[],
  ): string[] {
    if (credentials.scopes !== undefined) {
      return credentials.scopes;
    }
    return oAuth2Scopes;
  }
}
